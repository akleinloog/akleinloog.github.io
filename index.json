[{"authors":["admin"],"categories":null,"content":"Currently working as a software architect in a team focused on digital health solutions at Roche Diagnostics, I am passionate about all things related to software architecture and software engineering. Even more so when it comes to cloud native software, a world that I have just started to explore.\nI believe that cloud native software as a medical device (SaMD) has the potential to make advances in healthcare technology accessible to patients and medical professionals worldwide, and am looking forward to make my contribution towards unlocking this potential.\nTo be clear, all opinions expressed on this site are my own and do not necessarily represent the position of Roche or any of Roche\u0026rsquo;s affiliates.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1589750916,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://akleinloog.github.io/author/arnoud-kleinloog/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/author/arnoud-kleinloog/","section":"authors","summary":"Currently working as a software architect in a team focused on digital health solutions at Roche Diagnostics, I am passionate about all things related to software architecture and software engineering. Even more so when it comes to cloud native software, a world that I have just started to explore.","tags":null,"title":"Arnoud Kleinloog","type":"authors"},{"authors":["Arnoud Kleinloog"],"categories":null,"content":"As described here, I decided to use minikube to run a Kubernetes cluster on my dev machine. These are the details and some learnings along the way.\nPreparation As usual, before starting any experiments, I want my MacBook up to date, so I make sure that I have the latest updates installed. At the time of writing, these are macOS Catalina version 10.15.5 and Xcode version 11.5. Then I make sure that brew and any installed packages are up to date as well:\nbrew update brew upgrade brew cask upgrade  In addition, make sure there are no issues. If there are, resolve them first:\nbrew doctor  Should give the following output when all is ready:\nYour system is ready to brew.  Should you run into any issues, google is your friend\u0026hellip;\nIf you are running windows, chocolatey is a decent alternative to brew.\nIf not already installed, make sure you have Docker Desktop up and running. This should also come with Hyperkit, a lightweight hypervisor for macOS. You can find other alternatives here.\nInstallation Install minikube and kubectl:\nbrew install minikube brew install kubectl  First Cluster Create a cluster:\nminikube start  Gives an output similar to:\n😄 minikube v1.11.0 on Darwin 10.15.5 ✨ Using the hyperkit driver based on user configuration 🆕 Kubernetes 1.18.3 is now available. If you would like to upgrade, specify: --kubernetes-version=v1.18.3 👍 Starting control plane node minikube in cluster minikube 🔥 Creating hyperkit VM (CPUs=2, Memory=2048MB, Disk=20000MB) ... 🐳 Preparing Kubernetes v1.14.7 on Docker 19.03.8 ... 🔎 Verifying Kubernetes components... 🌟 Enabled addons: default-storageclass, storage-provisioner 🏄 Done! kubectl is now configured to use \u0026quot;minikube\u0026quot; ❗ /usr/local/bin/kubectl is version 1.18.3, which may be incompatible with Kubernetes 1.14.7. 💡 You can also use 'minikube kubectl -- get pods' to invoke a matching version  This tells us that the default Kubernetes version that was used is 1.14.7, and that the cluster has 2 CPUs, 2 GB of memory and 20 GB of disk spaces at its disposable. It also tells us that the latest available version of Kubernetes is 1.18.3. Since this is my dev machine, I want to use the latest Kubernetes version, and I want to assign more resources. Remove the cluster:\nminikube delete  Gives an output similar to:\n🔥 Deleting \u0026quot;minikube\u0026quot; in hyperkit ... 💀 Removed all traces of the \u0026quot;minikube\u0026quot; cluster.  Create a new cluster as follows:\nminikube start --kubernetes-version=v1.18.3 --cpus=4 --memory='8g' --disk-size='80000mb'  Gives an output similar to:\n😄 minikube v1.11.0 on Darwin 10.15.5 ✨ Using the hyperkit driver based on user configuration 👍 Starting control plane node minikube in cluster minikube 🔥 Creating hyperkit VM (CPUs=4, Memory=8192MB, Disk=80000MB) ... 🐳 Preparing Kubernetes v1.18.3 on Docker 19.03.8 ... 🔎 Verifying Kubernetes components... 🌟 Enabled addons: default-storageclass, storage-provisioner 🏄 Done! kubectl is now configured to use \u0026quot;minikube\u0026quot;  That is more like it. A local Kubernetes cluster up and running, and everything is up to date. If you want, you can open the kubernetes dashboard using:\nminikube dashboard  The dashboard will be installed and opened in a browser tab.\nPause and resume One very useful feature of minikube is that you can pause and resume your cluster. If you don\u0026rsquo;t need it for now, pause the cluster using:\nminikube stop  Gives an output similar to:\n✋ Stopping \u0026quot;minikube\u0026quot; in hyperkit ... 🛑 Node \u0026quot;minikube\u0026quot; stopped.  At a later point, you can resume it using:\nminikube start --kubernetes-version=v1.18.3  Gives an output similar to:\n😄 minikube v1.11.0 on Darwin 10.15.5 ✨ Using the hyperkit driver based on existing profile 👍 Starting control plane node minikube in cluster minikube 🔄 Restarting existing hyperkit VM for \u0026quot;minikube\u0026quot; ... 🐳 Preparing Kubernetes v1.18.3 on Docker 19.03.8 ... 🔎 Verifying Kubernetes components... 🌟 Enabled addons: default-storageclass, storage-provisioner 🏄 Done! kubectl is now configured to use \u0026quot;minikube\u0026quot;  Notice that you do need to provide the Kubernetes version if you specified one different from the default. This command can also be used to upgrade the Kubernetes version if a newer one becomes available.\nMultiple Clusters Another very useful feature of minikube is the ability to run multiple clusters. You can run them at the same time to do multi-cluster experiments, or pause / resume them when switching between projects. Let\u0026rsquo;s first delete the previously created cluster:\nminikube delete  Then create our first cluster:\nminikube start -p cluster1 --kubernetes-version=v1.18.3  And then a second one:\nminikube start -p cluster2 --kubernetes-version=v1.18.3  You can see the clusters using:\nkubectl config get-contexts  Gives an output similar to:\nCURRENT NAME CLUSTER AUTHINFO NAMESPACE cluster1 cluster1 cluster1 * cluster2 cluster2 cluster2  The * marks the currently selected context. You can also see that using:\n% kubectl config current-context cluster2  You can switch between clusters by selecting their context:\n% kubectl config use-context cluster1 Switched to context \u0026quot;cluster1\u0026quot;.  Stop one of the clusters if you don\u0026rsquo;t need it for now:\n% minikube stop -p cluster2 ✋ Stopping \u0026quot;cluster2\u0026quot; in hyperkit ... 🛑 Node \u0026quot;cluster2\u0026quot; stopped.  Resume it when you need it again:\n% minikube start -p cluster2 --kubernetes-version=v1.18.3 😄 [cluster2] minikube v1.11.0 on Darwin 10.15.5 ✨ Using the hyperkit driver based on existing profile 👍 Starting control plane node cluster2 in cluster cluster2 🔄 Restarting existing hyperkit VM for \u0026quot;cluster2\u0026quot; ... 🐳 Preparing Kubernetes v1.18.3 on Docker 19.03.8 ... 🔎 Verifying Kubernetes components... 🌟 Enabled addons: default-storageclass, storage-provisioner 🏄 Done! kubectl is now configured to use \u0026quot;cluster2\u0026quot;  And delete it when you don\u0026rsquo;t need it anymore:\n% minikube delete -p cluster2 🔥 Deleting \u0026quot;cluster2\u0026quot; in hyperkit ... 💀 Removed all traces of the \u0026quot;cluster2\u0026quot; cluster.  Next Steps\u0026hellip; Get more familiar with Kubernetes, follow some basic tutorials to deploy your first app here and find some more here. Again, google is your friend, there is plenty of content out there.\nAs for me, my next step will be to install Istio and make sure that my cluster can also be reached from other machines in my network. I\u0026rsquo;ll present the details in a following post\u0026hellip;\n","date":1590796800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590881074,"objectID":"eb34893593835e57eae4f2a4405ccb80","permalink":"https://akleinloog.github.io/post/minikube-kubernetes/","publishdate":"2020-05-30T00:00:00Z","relpermalink":"/post/minikube-kubernetes/","section":"post","summary":"Have Kubernetes up and running on your local dev machine.","tags":["Kubernetes","Minikube"],"title":"Minikube - Kubernetes for developers","type":"post"},{"authors":["Arnoud Kleinloog"],"categories":null,"content":"The goal of my Rapid API project is to create a containerized starting point that can be used to quickly implement a prototype of an API, customize it as needed, and easily add initial content.\nPreparation To get started, create a new GitHub repository, initialized it with a README and a license, and clone it to your local machine.\nDocker files Add a docker-compose.yaml file with the following content:\nversion: '3.7' services: rapid-api: container_name: api-dev build: ./docker/sqlite ports: - '8080:8080'  This file points to a Dockerfile in the /docker/sqlite folder and maps container port 8080 to host port 8080 so we can access our API.\nNext, add a docker folder with a sqlite sub folder. There, create a Dockerfile with the following content:\nFROM node:13.14.0-alpine3.11 RUN apk update \u0026amp;\u0026amp; apk upgrade RUN yarn global add strapi WORKDIR /app RUN strapi new . --quickstart --no-run RUN yarn install --force RUN strapi install documentation \u0026amp;\u0026amp; strapi install graphql RUN sed -i 's/1337/8080/g' ./config/server.js COPY settings.json /app/extensions/documentation/config/ COPY entrypoint.sh /usr/local/bin/ RUN chmod 755 \u0026quot;/usr/local/bin/entrypoint.sh\u0026quot; EXPOSE 8080 ENTRYPOINT [\u0026quot;/usr/local/bin/entrypoint.sh\u0026quot;]  As you can see, the Dockerfile uses the latest Node JS 13 version. At the time of writing, Node JS 14 has already been released, but not all of strapi\u0026rsquo;s dependencies were available at the time of writing.\nThe docker build starts with installing the strapi CLI, which it then uses to create a new quickstart project. This initializes a strapi project using a SQLite database. It then installs the API documentation and GraphQL plugins and changes the default port number from 1337 to 8080. In addition, it copies a settings.json file and an entrypoint.sh file to the image.\nOpen API settings Next to the Dockerfile in the sqlite folder, add a settings.json file with the following content:\n{ \u0026quot;openapi\u0026quot;: \u0026quot;3.0.0\u0026quot;, \u0026quot;info\u0026quot;: { \u0026quot;version\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;DOCUMENTATION\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;termsOfService\u0026quot;: \u0026quot;YOUR_TERMS_OF_SERVICE_URL\u0026quot;, \u0026quot;contact\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;TEAM\u0026quot;, \u0026quot;email\u0026quot;: \u0026quot;contact-email@something.io\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;mywebsite.io\u0026quot; }, \u0026quot;license\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;Apache 2.0\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://www.apache.org/licenses/LICENSE-2.0.html\u0026quot; } }, \u0026quot;x-strapi-config\u0026quot;: { \u0026quot;path\u0026quot;: \u0026quot;/documentation\u0026quot;, \u0026quot;showGeneratedFiles\u0026quot;: true, \u0026quot;pluginsForWhichToGenerateDoc\u0026quot;: [ \u0026quot;email\u0026quot;, \u0026quot;upload\u0026quot;, \u0026quot;users-permissions\u0026quot; ] }, \u0026quot;servers\u0026quot;: [ { \u0026quot;url\u0026quot;: \u0026quot;http://localhost:8080\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Development server\u0026quot; }, { \u0026quot;url\u0026quot;: \u0026quot;YOUR_STAGING_SERVER\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Staging server\u0026quot; }, { \u0026quot;url\u0026quot;: \u0026quot;YOUR_PRODUCTION_SERVER\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Production server\u0026quot; } ], \u0026quot;externalDocs\u0026quot;: { \u0026quot;description\u0026quot;: \u0026quot;Find out more\u0026quot;, \u0026quot;url\u0026quot;: \u0026quot;https://strapi.io/documentation/\u0026quot; }, \u0026quot;security\u0026quot;: [ { \u0026quot;bearerAuth\u0026quot;: [] } ], \u0026quot;paths\u0026quot;: {}, \u0026quot;tags\u0026quot;: [], \u0026quot;components\u0026quot;: {} }  This file is needed in order to correct the port number used by the Open API endpoint. Feel free to edit the other settings to your liking. For more info, see this section in the strapi documentation.\nEntrypoint Next to the Dockerfile in the sqlite folder, add an entrypoint.sh file with the following content:\n#!/bin/sh # exit when any command fails set -e echo \u0026quot;Starting Server\u0026quot; strapi develop  This entrypoint script simply starts the strapi project in development mode, with automatic reload enabled.\nFirst run Startup the container for the first time:\ndocker-compose up --build  It will take a while before we are ready for the next steps. The base image is downloaded, updates are installed, the strapi project is initialized and the Documentation and GraphQL plugins are installed. Once this is completed, the container is started and some log entries appear. Eventually you will see something like this, indicating that the container is successfully started:\napi-dev | One more thing... api-dev | Create your first administrator 💻 by going to the administration panel at: api-dev | api-dev | ┌─────────────────────────────┐ api-dev | │ http://localhost:8080/admin │ api-dev | └─────────────────────────────┘ api-dev |  You are now read to navigate to http://localhost:8080/admin, create an admin account and start customizing your API.\nAdding Content Let\u0026rsquo;s add a first example resource together.\nFrom the menu on the left, select the Content-Types Builder and choose Create new collection type. Give it a display name Example and continue. Now we can add our choice of fields to our collection type: As you can see, strapi comes with a nice set of built-in field types. Feel free to experiment with them. For now, we will just add a Text field called Name and a Rich Text field called Description. Hit Finish and then Save. Strapi will now generate the Example API and restart the server. Once complete, you will see the Example collection type appear in the top left. Open it up and add a few examples.\nCheckout the strapi documentation and tutorials for more examples.\nTest the API Now that we have added some content and created our first API, we want to see it in action. You can use the API client of your choice to test it (postman, insomnia, curl, etc,) At the moment, I prefer to use Visual Studio Code with the REST Client plugin. Add a test.http file with the first test:\n### GET http://localhost:8080/examples  A little Send Request label will appear, and when you click that, Visual Studio Code will execute the GET request. You will get a response like this:\nHTTP/1.1 403 Forbidden ... Connection: close { \u0026quot;statusCode\u0026quot;: 403, \u0026quot;error\u0026quot;: \u0026quot;Forbidden\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;Forbidden\u0026quot; }  Your API supports authentication and is not open to the public! For the sake of this test, in your strapi Admin UI, navigate to Roles \u0026amp; Responsibilities, select Public and check Select All next to Example and save that. Now try sending the request again, you should receive the examples that you\u0026rsquo;ve added previously.\nFor our last exercise, let\u0026rsquo;s use the API to add another entry. Add the following to the test.http file:\n### POST http://localhost:8080/examples content-type: application/json { \u0026quot;name\u0026quot;: \u0026quot;API Example\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Added using the API\u0026quot; }  Don\u0026rsquo;t forget the content-type header! Strapi will check for this and create an entry with empty values if you forget to specify that!\nAPI Documentation You will find another nice feature of our setup when you navigate to Documentation. Click in the Retrieve your jwt token textbox and the token will be copied to the clipboard. Click on Open the documentation and the Swagger based OpenAPI endpoint will be opened. You can Authorize yourself with your token and get familiar with all the options that your API has to offer.\nGraphQL A main reason for me to try strapi for rapid API prototyping is its support for GraphQL. I am not yet very familiar with GraphQL and want to have a playground to learn more.\nYour API\u0026rsquo;s GraphQL Playground is available at http://localhost:8080/graphql. See this section in the strapi documentation for more info.\nEven easier\u0026hellip; Don\u0026rsquo;t want to go through the effort described above? I\u0026rsquo;ll do you one better. The resulting container image is available here on docker hub, so you can get started with a single line:\ndocker run -p 8080:8080 akleinloog/rapid-api  The code If you want to see how to set up a prototype using MongoDB instead of SQLite, or wonder how I built and published the container image to docker hub, feel free to check out the repository on Github.\n","date":1590537600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590619469,"objectID":"5a7552cba49675e894c2d580af015b1e","permalink":"https://akleinloog.github.io/post/rapid-api-prototype/","publishdate":"2020-05-27T00:00:00Z","relpermalink":"/post/rapid-api-prototype/","section":"post","summary":"Rapidly develop API prototypes using strapi.","tags":["API","REST","GraphQL","Prototyping","strapi"],"title":"Rapid API Prototyping","type":"post"},{"authors":null,"categories":null,"content":"This goal of this project is to create a simple HTTP Logger in Go, that logs all incoming HTTP requests in a structured way.\nThe What A Simple HTTP Logger that can be configured to run on any port.\nMy main requirements:\n Log HTTP GET, POST, PUT and other methods to stdout Always return 200 OK as response Structured logging in JSON format Log Host, URL, Method, IP addresses, request body and more Containerized, lightweight, easily usable in different environments  Additional nice to haves:\n Enforce SSL with redirect and correct certificates Easy configuration (flags, environment settings, config files) Easy way to access request body  The Why The HTTP Logger can be used to gain some insights into HTTP traffic, for example, when you want to test if a webhook is properly sending messages, and what the content of these messages is.\nIn addition, it is a perfectly small Microservice, ideally suited to learn some Go development practices that could be suited for other Microservices too.\nThe How The HTTP Logger will be implemented using Go, a language that I am not yet familiar with, but really want to learn. And for me, the best way to learn after some basic tutorials is to put things into practice.\nIn order to learn a bit more about Go, I will pay attention to:\n Structured Logging (stdout in JSON) Flexible Configuration (Support for Flags, Environment, Config file, etx) Proper CLI support  The Results I just started this project, so there are no results to share just yet. I will detail the progress in a series of blog posts and update this section when the HTTP Logger is available.\nIn the end, my solution will be publicly available on GitHub and on Docker, for you to use freely, to learn from, and hopefully, to provide some feedback on!\n","date":1590105600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590168296,"objectID":"cf35cdfd6956de0de868fce01ec1a116","permalink":"https://akleinloog.github.io/project/http-logger/","publishdate":"2020-05-22T00:00:00Z","relpermalink":"/project/http-logger/","section":"project","summary":"A simple HTTP Logger that logs all requests, written in Go.","tags":["Go","Docker"],"title":"HTTP Logger","type":"project"},{"authors":["Arnoud Kleinloog"],"categories":null,"content":" Kubernetes is the state-of-the-art when it comes to container orchestration.\nIt was built upon years of experience with production workloads at Google, combined with best-of-breed ideas and practices from the community. It is available Open Source and vendor neutral and runs basically everywhere.\nToday, I see Kubernetes as the Operating System of the Cloud Native world.\nIt provides the base environment for my containerized applications, and as such, it is important to me to have it running locally on my development PC.\nTo this end, several decent options are available. Which to choose when?\nMy Requirements As always, choosing a solution works best if you understand your needs. Since this is for my local development environment, my must haves are:\n Runs on my laptop Easy to install, configure and automate Wide support of Kubernetes versions and features Cross Platform, available for Mac, Windows and Linux  In addition, I would like to use the same solution on a single machine personal development server. Using different solutions is an option.\nThe Alternatives So far, I have identified the following potential solutions:\n Docker Desktop ships with a bundled Kubernetes offering. The Kubernetes version it supports is tightly coupled with the Docker version. The current version (2.2.0.5) supports Kubernetes version 1.15.5. I have not found a programmatic way to create and destroy a new Kubernetes cluster. It can only be done using the Docker desktop app preferences.\n Kind - Kubernetes IN Docker - is a tool for running local Kubernetes clusters using Docker containers as nodes. It is an Open Source project managed by the Kubernetes Community and was primarily designed for testing Kubernetes itself. Kind supports multi-node (including HA) clusters and is optimized for CI pipelines.\n Minikube sets up a local single node Kubernetes cluster using a VM. It is another Open Source project managed by the Kubernetes Community and was designed to make it simple to run Kubernetes locally, for day-to-day development workflows and learning purposes. Minikube supports multiple container runtimes and advanced features such as Load Balancer, filesystem mounts, and Feature Gates.\n K3d is a lightweight wrapper to run k3s (Rancher Lab’s minified Kubernetes distribution) in docker. By removing dispensable features (legacy, alpha, non-default, in-tree plugins) and using lightweight components (e.g. sqlite3 instead of etcd3) Rancher Labs created an ultra small Kubernetes distribution built for IoT and Edge computing. It supports ARMv7 and ARM64 architectures, making it possible to run a Kubernetes cluster on a set of Raspberry Pis.\nOther potential alternatives like Microk8s, Kubeadm, Kubespray and Kops where discarded, either because they are not Cross Platform or are geared towards production environments.\nHow do they compare? The following table lists the alternatives along with some of their characteristics:\n Nodes: The number of cluster nodes supported CLI: Command Line Interface for installation and configuration Multiple: Supports multiple clusters on a single machine Versions: Support for different Kubernetes versions Features: Support for Kubernetes features Resources: Resource usage when compare to each other Pauseable: Cluster can be stopped and restarted      Nodes CLI Multiple Versions Features Resources Pauseable     Minikube 1 Yes Yes High Highest High Yes   Kind n Yes Yes High High Medium No   K3d n No Yes Low Medium Low No   Docker 1 No No Single High Medium No    Conclusion This exercise provided me with some interesting insights.\nI discard the Docker Desktop version, mainly because it only supports a single Kubernetes version and I have not found a way to programmatically create, configure and destroy the cluster.\n k3s has gotten my attention. Especially the idea of running a Kubernetes cluster on a set of Raspberry PIs definitely made it on my wish list.\nFor my development environment, I am tending towards using something that is managed by the Kubernetes Community. They have done an awesome job with Kubernetes, and I expect less hassle using either Kind or Minikube.\nFor now, I\u0026rsquo;ll get started with Minikube, as it promises the best support for my development workflows. I will detail my setup and learnings in a follow up post. At a later state, I may also add Kind to the mix to experiment with certain failure scenarios.\nAnd when the time comes to develop solutions targeting IoT and Edge computing I can use K3d to test on my local environment.\nCheck here for a list of certified Kubernetes offerings and here for the details on which Kubernetes versions are supported.\nIf you feel like I have missed something, or do not agree with my conclusions, please leave a note!\n","date":1590105600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590243500,"objectID":"fe81ae21babf0c3872dba8c395bc5942","permalink":"https://akleinloog.github.io/post/which-local-kubernetes/","publishdate":"2020-05-22T00:00:00Z","relpermalink":"/post/which-local-kubernetes/","section":"post","summary":"What is the best way to run local Kubernetes clusters on my developer machine? Taking a look at Docker vs Kind vs Minikube vs K3d.","tags":["Kubernetes","Minikube","Kind","K3s","Docker"],"title":"Which Kubernetes to use on my development PC?","type":"post"},{"authors":null,"categories":null,"content":"This goal of this project is to come up with an approach for rapid prototyping of APIs that support both REST and GraphQL.\nThe What A containerized starting point that can be used to quickly implement a prototype of an API, customize it as needed, and easily add initial content.\nMy main requirements:\n Support for RESTful APIs Support for GraphQL APIs Easily modify the API and add initial content Free of costs (no licence fees)  Additional nice to haves:\n Support for Webhooks Support for Authentication Support for Open API documentation  The Why Every now and then I find myself in a situation where I need to quickly create a prototype of an API. This often happens when exploring a design for a new Microservice, especially when that Microservice depends on other services.\nIn order to properly allocate responsibilities and design the interactions between these Microservice, I often find it useful to create some working prototypes of the Microservices I depend on.\nBeing able to do so quickly, while having a rich feature set at the same time, enables me to follow the show me approach to software architecture, which I find far more interesting and effective, and therefore more valuable, than the more common diagrams-based tell me approach.\nThe How The strapi project was initially created to bootstrap APIs. Even though it is now advertised as a Headless CMS, from what I have seen, it could be a very good fit for what I need.\nBased on strapi, I will create a docker image that is pre-configured and ready to use. In the process, I will tailor the image to my needs and in addition, set up an automated build that pushes new versions of that image to docker hub. This is something that I did not do before, so a good opportunity to learn.\nThe Results See this post for a detailed description of the process and how to use it.\nThe resulting container to get you going with rapid API prototyping is available on docker hub here and can be started as follows:\ndocker run -p 8080:8080 akleinloog/rapid-api  The code is available in this GitHub repository.\nUse it freely, learn from it, and ideally, provide some feedback!\n","date":1589587200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590619684,"objectID":"c9c9ea68ad32475689b1ee751020b92b","permalink":"https://akleinloog.github.io/project/rapid-api/","publishdate":"2020-05-16T00:00:00Z","relpermalink":"/project/rapid-api/","section":"project","summary":"Rapid API prototyping of RESTful and GraphQL based APIs.","tags":["API","REST","GraphQL","Prototyping","strapi"],"title":"Rapid API","type":"project"},{"authors":["Arnoud Kleinloog"],"categories":null,"content":"This is the second part in a series of posts detailing the set up of my personal blog. It details how to enable google analytics, commenting and a simple contact page. See part 1 for the basic setup.\nEnable Google Analytics  Google Analytics can provide you with some interesting insights on your site\u0026rsquo;s visitors and the way they use your site. Enabling it on my personal blog provides a nice opportunity to learn a bit more about the possibilities it offers to site owners.\nLucky for me, it is a straight forward exercise. After signing up for google analytics and creating an account for your website, all you need to do is open your params.toml in _/config/default and add the account id:\n############################ ## Marketing ############################ [marketing] google_analytics = \u0026quot;UA-***\u0026quot; # google_tag_manager = \u0026quot;\u0026quot;  I signed up for Google Tag Manager as well, and tried to activate it, but no luck so far. In order to get Google Analytics to work I had to comment out the google_tag_manager entry. If I decide to take another look at this and get it to work, I\u0026rsquo;ll detail it in a follow up post.\nThe next step is to configure the base URL of your site, in config.toml in _/config/default. If you used a custom domain:\n# The URL of your site. baseurl = \u0026quot;https://www.yourdomain.com/\u0026quot;  Otherwise, use your GitHub Pages URL:\n# The URL of your site. baseurl = \u0026quot;https://\u0026lt;username here\u0026gt;.github.io/\u0026quot;  The last change is an improvement to the deploy script we created in the previous post. In deploy.sh replace the following:\necho \u0026quot;Running Hugo Build\u0026quot; hugo -t academic  with:\necho \u0026quot;Running Hugo Build\u0026quot; env HUGO_ENV=\u0026quot;production\u0026quot; hugo --gc --minify -t academic -b https://\u0026lt;username here\u0026gt;.github.io  Doing so will activate the Google Analytics scripts when the site is running in production. In addition, it also instructs Hugo to run some cleanup tasks after the build and to minify the output, something I didn\u0026rsquo;t pay attention to in my previous post.\nEnable Google Search Console Another thing I decided to add is Google Search Console, another free-to-use service offered by Google that helps you monitor, maintain, and troubleshoot your site\u0026rsquo;s presence in Google Search results.\nAfter using the \u0026lsquo;URL prefix\u0026rsquo; method, my site ownership was automatically verified based on the Google Analytics account. I added an additional verification method by going to Settings-\u0026gt;Ownership Verification, and selecting HTML File. Download the file, add it to your /static folder and redeploy the site:\n./deploy.sh  Of course I realize that, as is the case with most \u0026lsquo;free service\u0026rsquo; offerings, I am being part of the product here. Google will use all information they get in ways they see fit. Since what I am doing here is \u0026lsquo;out in the open\u0026rsquo; and dedicated to the public domain, I figured it would make a good opportunity to learn more about these Google services, and I appreciate that the collected information (or at least some of it) is shared with me as well.\nCommenting with Disqus Enabling others to comment on your site turns it into an interactive site and is relatively easy to do. First go to https://disqus.com and sign up. I selected the basic, free package. Then open params.toml in your _config/default directory and fill in the comments section to enable commenting:\n############################ ## Comments ############################ [comments] ... engine = 1 ... [comments.disqus] shortname = \u0026quot;\u0026lt;shortname\u0026gt;\u0026quot; # Paste the shortname from your Disqus dashboard  When you run the site locally, the commenting section won\u0026rsquo;t be enabled, but you should see a warning like \u0026ldquo;Disqus comments not available by default when the website is previewed locally.\u0026quot; at the bottom of your posts.\nDeploy your website to production and see how it works!\nContact Page Adding a simple contact page can be done with Academic\u0026rsquo;s contact widget.\nFor this side, I decided to add it to the bottom of the about page, and in addition, add a top-level menu and a link from my profile.\nTo add a top level menu, open _config/default/menus.toml and add:\n[[main]] name = \u0026quot;Contact\u0026quot; url = \u0026quot;about/#contact\u0026quot; weight = 50  In _config/default/params.toml, make sure that an email address is configured.\nTo add a link from your profile, open _authors/admin/index.md and add this to the social section:\n- icon: envelope icon_pack: fas link: 'about/#contact'  To add the contact form itself, in the content/about/ folder, add contact.md with the following content:\n+++ # Contact widget. widget = \u0026quot;contact\u0026quot; headless = true active = true weight = 50 title = \u0026quot;Contact\u0026quot; subtitle = \u0026quot;\u0026quot; # Automatically link email and phone? autolink = true # Email form provider # 0: Disable email form # 1: Netlify (requires that the site is hosted by Netlify) # 2: formspree.io email_form = 2 +++  This sets up your site to use Formspree to email you the request. After deploying to production, simply fill in the form once and you will receive an email to complete your registration. Their free plan gives you a limited amount of monthly submissions.\nThe contact widget can be further customized by providing additional information in your params.toml, see the docs for more detail.\n","date":1588982400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589750916,"objectID":"2e115cc785622b6d201466043655c22e","permalink":"https://akleinloog.github.io/post/my-blog-pt2/","publishdate":"2020-05-09T00:00:00Z","relpermalink":"/post/my-blog-pt2/","section":"post","summary":"How to add Google Analytics and google Google Search Console .","tags":["Academic","Hugo"],"title":"Setting up this Blog - Part 2","type":"post"},{"authors":["Arnoud Kleinloog"],"categories":null,"content":"This is the first in a series of posts detailing the set up of my personal blog. It covers the basic steps needed to get started.\nI use Hugo as a static site generator and Visual Studio Code as editor. The resulting website is hosted using GitHub Pages. A nice combination of open source tools with a free hosting provider that poses no restrictions in terms of traffic, size, etc. Sounds like a perfect match to me.\nFamiliarity with git and the command line are assumed. I use a Mac, some of the commands may need to be translated to your environment.\nGetting started Following this Hugo tutorial, I created two repositories on GitHub. One named website for the sources, and another one for the generated website.\n The name of the repository for the generated website has to be specific in order for it to be picked up by GitHub Pages. In my case: akleinloog.github.io   I decided to dedicate both repositories to the public domain and therefore used the UNLICENSE. Feel free to use anything you find there as you see fit.\nThe next step is to clone the repository used for the source:\ngit clone https://github.com/\u0026lt;username here\u0026gt;/website.git  And open the project in Visual Studio Code:\ncd website code .  Add the following .gitignore file and optionally, save the code workspace:\n# MacOS Files .DS_Store # Hugo Working Folders resources/  Install Hugo if not already installed:\nbrew install hugo  And initialize your repository for Hugo:\nhugo new site . --force  Select a theme A good overview of available themes can be found here. Select Hugo and order the themes by Stars gives you an overview of the most used themes.\nI decided to try Academic, a feature rich, open source theme developed by George Cushen and made available under the MIT license. Thanks George!\nAdd the theme as a git submodule:\ngit submodule add https://github.com/gcushen/hugo-academic.git themes/academic  Familiarize yourself with Academic, and customize it as you see fit. A good way to do that, is to clone the Academic Kickstart project in a separate directory. It provides a good demonstration of what the theme has to offer.\nAdd some content First add the configuration files. You can copy the ones from the Academic Kickstart project to get started. Read through them and adjust as you see fit.\nAlso copy the page_sharer.toml file in the data folder to your local project.\nPlaying around with Academic\u0026rsquo;s many widgets using the Kickstart project should give you a fair idea on what other content you want to add. You can also have a look at my sources repository to see what I did for this blog.\nTry it out locally Experiment with the configuration options and the structure. Run the site in development mode using:\nhugo server  The site will be available at http://localhost:1313. Whenever you save your changes, Hugo will react and automatically refresh the website, providing a very pleasant live-editing experience.\nGet ready to publish Add the repository for the generated website as a git submodule:\ngit submodule add -b master https://github.com/\u0026lt;username here\u0026gt;/\u0026lt;username here\u0026gt;.github.io.git public  Doing so ensures that the HTML and JavaScript generated by Hugo will be placed in that repository.\nFirst, we\u0026rsquo;ll do a manual run. Generate your website:\nhugo -t academic  Test the generated output using the serve package:\ncd public npx serve  Automate it Add a file called deploy.sh to the sources repository\u0026rsquo;s main folder. Ensure it is executable:\nchmod +x deploy.sh  Add the following content to that file:\n#!/bin/sh set -e echo \u0026quot;Cleaning Publish Folder\u0026quot; rm -r ./public/* echo \u0026quot;Running Hugo Build\u0026quot; hugo -t academic cd public echo \u0026quot;Adding changes to git\u0026quot; git add . msg=\u0026quot;regenerating site content $(date)\u0026quot; git commit -m \u0026quot;$msg\u0026quot; echo \u0026quot;Pushing to master\u0026quot; git push origin master cd .. echo \u0026quot;Deployment Finished\u0026quot;  This script uses Hugo to generate your website and commit the changes to the generated website repository. By pushing these changes to GitHub, the script effectively deploys your website to production. Give it a try:\n./deploy.sh  Navigate to your GitHub Pages URL to see the result!\nAdd a custom domain name Using a custom domain name for your GitHub pages is relatively straight forward. First register a domain name and then configure the DNS settings.\nCreate the following A records for your domain to point it to GitHub\u0026rsquo;s servers:\n185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153  Then add a CNAME record for www that points to the your GitHub site.\nThen go to the GitHub repository settings of your generated site. In the GitHub Pages section, enter the domain you\u0026rsquo;ve registered in the custom domain field, with the www. prefix, and save it. This will trigger a check-in that adds a CNAME file with the domain that you have specified.\nKeep in mind that may take some time for DNS changes to take effect, and for the SSL certificates to be generated. Once completed, check the \u0026lsquo;Enforce HTTPS\u0026rsquo; checkbox and the setup is completed.\nYour domain name will be forwarded to your www. and so will your GitHub pages and HTTPS will be automatically enforces, with valid a certificate for your URL, free of charge!\nSee the GitHub Pages docs for more information and troubleshooting tips.\nUpdate your sources repository The last thing to do, before making other modifications to your site, is to secure the CNAME file in your sources repository so that it does not get deleted when you regenerate your website. First pull the changes:\ncd public git pull --all  This will update your local module and add the CNAME file. Now copy that file from the public folder to the static folder so it will be re-added when the site is regenerated. Commit and push your changes and you are good to go!\nNext Steps I hope you have enjoyed this as much as I did, in Part 2 I will add support for Google Analytics, comments and a simple contact page.\n","date":1588723200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590881074,"objectID":"b49638f9d39038b22b0383ee21a254e3","permalink":"https://akleinloog.github.io/post/my-blog-pt1/","publishdate":"2020-05-06T00:00:00Z","relpermalink":"/post/my-blog-pt1/","section":"post","summary":"How to set up a simple blog with Hugo and GitHub Pages.","tags":["Academic","Hugo"],"title":"Setting up this Blog - Part 1","type":"post"},{"authors":null,"categories":null,"content":"The goal of this project was to set up a simple website to use as a personal blog. You are currently looking at the result of this!\nThe What The basic idea was to set up a blog where I can easily manage my posts and provide some info on myself and the projects I work on. Having played around with Wordpress in the past, I wanted something different this time.\nMy main requirements:\n Easy to use (for me) Easy to host Free of costs (no licence or hosting fees) Learn something new in the process  The Why My main motivation is to have a place to keep track of the many technical experiments I do and their outcomes. A blog that allows me to write small posts, tag them, and easily search through them seemed like a good solution.\nIf others can also find these experiments and learn from them, that would be an additional benefit. And if they in turn can provide feedback, even better.\nThe How After looking around a bit I decided to try out the following:\n Use Hugo, a Static Site Generator written in Go Write the content in markdown Use a GitHub repository to keep the sources Use another GitHub repository to host the resulting blog Open Source the result so others might learn from it  The Results The current state of this project is open for all to see. Look around and take a look at the sources if you are interested.\nThis is still a work in progress, I will add some posts that detail what I did and what I used, and hope to add some additional features soon, for example, the possibility for others to comment.\nI hope you will find this useful somehow!\n","date":1588636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590168296,"objectID":"8174ecd8e0648e049ff264ac750633bb","permalink":"https://akleinloog.github.io/project/personal-blog/","publishdate":"2020-05-05T00:00:00Z","relpermalink":"/project/personal-blog/","section":"project","summary":"A simple website to be used as my personal blog.","tags":["Hugo"],"title":"Personal Blog","type":"project"},{"authors":null,"categories":null,"content":"","date":1588377600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588623963,"objectID":"8576ec274c98b3831668a172fa632d80","permalink":"https://akleinloog.github.io/about/","publishdate":"2020-05-02T00:00:00Z","relpermalink":"/about/","section":"","summary":"About the author","tags":null,"title":"About","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1588377600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588625778,"objectID":"475f2249a5c02879faf32697c0e89e6e","permalink":"https://akleinloog.github.io/portfolio/","publishdate":"2020-05-02T00:00:00Z","relpermalink":"/portfolio/","section":"","summary":"Some of the projects I have been working on","tags":null,"title":"Projects","type":"widget_page"}]