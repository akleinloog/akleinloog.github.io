<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>My Site</title><link>https://www.kleinloog.ch/</link><atom:link href="https://www.kleinloog.ch/index.xml" rel="self" type="application/rss+xml"/><description>My Site</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>Dedicated to the public domain Â· [Unlicensed](https://github.com/akleinloog/akleinloog.github.io/blob/master/LICENSE)</copyright><lastBuildDate>Fri, 05 Jun 2020 00:00:00 +0000</lastBuildDate><image><url>https://www.kleinloog.ch/images/icon_hu1d96926d990b8c2ce1741b9516caf288_71361_512x512_fill_lanczos_center_2.png</url><title>My Site</title><link>https://www.kleinloog.ch/</link></image><item><title>Go CLI</title><link>https://www.kleinloog.ch/post/go-cli/</link><pubDate>Fri, 05 Jun 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/post/go-cli/</guid><description>&lt;p>Let&amp;rsquo;s set up a decent Command Line Interface (CLI) for our Go project.
This has been made easy by &lt;a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">Cobra&lt;/a>, a library that provides a simple interface to create a powerful modern CLI, like you are used to from git, kubectl, etc.&lt;/p>
&lt;p>Cobra comes with a very nice set of features, amongst which:&lt;/p>
&lt;ul>
&lt;li>Easily add commands and nested commands&lt;/li>
&lt;li>Support for flags (including short &amp;amp; long versions)&lt;/li>
&lt;li>Intelligent suggestions (app srver&amp;hellip; did you mean app server?)&lt;/li>
&lt;li>Automatic help generation and support of -h and --help&lt;/li>
&lt;li>Automatically generated bash autocomplete and man pages&lt;/li>
&lt;/ul>
&lt;h3 id="installation">Installation&lt;/h3>
&lt;p>To get started, we&amp;rsquo;ll create a new go project and initialize it, in my case:&lt;/p>
&lt;pre>&lt;code class="language-bash">go mod init github.com/akleinloog/hello
&lt;/code>&lt;/pre>
&lt;p>Then, install the latest version of Cobra:&lt;/p>
&lt;pre>&lt;code class="language-bash">go get github.com/spf13/cobra/cobra
&lt;/code>&lt;/pre>
&lt;p>And initialize the new project:&lt;/p>
&lt;pre>&lt;code class="language-bash">cobra init --pkg-name github.com/akleinloog/hello
&lt;/code>&lt;/pre>
&lt;p>This adds a &lt;em>main.go&lt;/em> file and a &lt;em>cmd&lt;/em> folder with a &lt;em>root.go&lt;/em> file.
The main.go file is very simple, contains some license info and a simple main function:&lt;/p>
&lt;pre>&lt;code class="language-go">package main
import &amp;quot;github.com/akleinloog/hello/cmd&amp;quot;
func main() {
cmd.Execute()
}
&lt;/code>&lt;/pre>
&lt;p>Take a look at the &lt;em>root.go&lt;/em> file in the &lt;em>cmd&lt;/em> folder, and you will notice a few things.
First, it contains a use instruction and a short and a long description.
Change the text to something meaningful for your example. In my case:&lt;/p>
&lt;pre>&lt;code class="language-go">var rootCmd = &amp;amp;cobra.Command{
Use: &amp;quot;hello&amp;quot;,
Short: &amp;quot;Go Hello&amp;quot;,
Long: `A simple HTTP Server written in Go.
It gives out a simple Hello message with a counter, the host name and the requested address.`,
}
&lt;/code>&lt;/pre>
&lt;p>It is good practice not to define an action here. In that case, Cobra will ensure to give out a nice set of instructions.
See for yourself:&lt;/p>
&lt;pre>&lt;code class="language-bash">go build
./hello
&lt;/code>&lt;/pre>
&lt;p>Another thing to notice is that cobra added an &lt;em>Execute()&lt;/em> function, an &lt;em>init()&lt;/em> function and an &lt;em>initConfig()&lt;/em> function.
With that, it added &lt;a href="https://github.com/spf13/viper" target="_blank" rel="noopener">Viper&lt;/a> and support for a configuration file.
We&amp;rsquo;ll add another flag later on, and I will discuss Viper and proper configuration in another post.&lt;/p>
&lt;h3 id="adding-commands">Adding Commands&lt;/h3>
&lt;p>Let&amp;rsquo;s first add a new command that will start our HTTP Server:&lt;/p>
&lt;pre>&lt;code class="language-bash">cobra add serve
&lt;/code>&lt;/pre>
&lt;p>Cobra added a &lt;em>serve.go&lt;/em> file in the &lt;em>cmd&lt;/em> folder, similar to the &lt;em>root.go&lt;/em> we saw earlier.
This time it adds a serve command. Let&amp;rsquo;s update the text again:&lt;/p>
&lt;pre>&lt;code class="language-go">var serveCmd = &amp;amp;cobra.Command{
Use: &amp;quot;serve&amp;quot;,
Short: &amp;quot;Starts the HTTP Server.&amp;quot;,
Long: `Starts the HTTP Server listening at port 80, where it will return a simple hello on any request.`,
Run: func(cmd *cobra.Command, args []string) {
fmt.Println(&amp;quot;serve called&amp;quot;)
},
}
&lt;/code>&lt;/pre>
&lt;p>In the &lt;em>init()&lt;/em> method you see that the command is added to the root command:&lt;/p>
&lt;pre>&lt;code class="language-go">func init() {
rootCmd.AddCommand(serveCmd)
...
}
&lt;/code>&lt;/pre>
&lt;p>Rebuild and run again:&lt;/p>
&lt;pre>&lt;code class="language-bash">go build
./hello
&lt;/code>&lt;/pre>
&lt;p>Notice that the output has now changed.
Information is provided on the commands and on flags that are supported.&lt;/p>
&lt;p>Try the help:&lt;/p>
&lt;pre>&lt;code class="language-bash">./hello serve -h
&lt;/code>&lt;/pre>
&lt;p>Help specific to the serve command is provided.&lt;/p>
&lt;p>Now try the actual command:&lt;/p>
&lt;pre>&lt;code class="language-bash">./hello serve
&lt;/code>&lt;/pre>
&lt;p>You should see the simple &amp;lsquo;serve called&amp;rsquo; output.&lt;/p>
&lt;h3 id="add-the-http-server">Add the HTTP Server&lt;/h3>
&lt;p>Let&amp;rsquo;s implement the HTTP server. We&amp;rsquo;ll keep it simple.
In &lt;em>serve.go&lt;/em> add the following functions:&lt;/p>
&lt;pre>&lt;code class="language-go">var (
requestNr int64 = 0
host string = &amp;quot;unknown&amp;quot;
)
func listen() {
currentHost, err := os.Hostname()
if err != nil {
log.Println(&amp;quot;Could not determine host name:&amp;quot;, err)
} else {
host = currentHost
}
log.Println(&amp;quot;Starting Hello Server on &amp;quot; + host)
http.HandleFunc(&amp;quot;/&amp;quot;, hello)
err = http.ListenAndServe(&amp;quot;:80&amp;quot;, nil)
if err != nil {
log.Fatal(err)
}
}
func hello(w http.ResponseWriter, r *http.Request) {
requestNr++
message := fmt.Sprintf(&amp;quot;Go Hello %d from %s on %s ./%s\n&amp;quot;, requestNr, host, r.Method, r.URL.Path[1:])
log.Print(message)
fmt.Fprint(w, message)
}
&lt;/code>&lt;/pre>
&lt;p>And change the serve command to:&lt;/p>
&lt;pre>&lt;code class="language-go">var serveCmd = &amp;amp;cobra.Command{
Use: &amp;quot;serve&amp;quot;,
Short: &amp;quot;Starts the HTTP Server.&amp;quot;,
Long: `Starts the HTTP Server listening at port 80, where it will return a simple hello on any request.`,
Run: func(cmd *cobra.Command, args []string) {
listen()
},
}
&lt;/code>&lt;/pre>
&lt;p>Rebuild and run the server:&lt;/p>
&lt;pre>&lt;code class="language-bash">go build
./hello serve
&lt;/code>&lt;/pre>
&lt;p>The HTTP Server will start and you can visit &lt;a href="http://localhost" target="_blank" rel="noopener">http://localhost&lt;/a> to see the result.&lt;/p>
&lt;h3 id="add-an-http-client">Add an HTTP Client&lt;/h3>
&lt;p>Let&amp;rsquo;s add another command that will serve as a client for our Server:&lt;/p>
&lt;pre>&lt;code class="language-bash">cobra add get
&lt;/code>&lt;/pre>
&lt;p>Add the following function to &lt;em>get.go&lt;/em>:&lt;/p>
&lt;pre>&lt;code class="language-go">func get() {
resp, err := http.Get(&amp;quot;http://localhost&amp;quot;)
if err != nil {
log.Println(err)
}
defer resp.Body.Close()
scanner := bufio.NewScanner(resp.Body)
for i := 0; scanner.Scan() &amp;amp;&amp;amp; i &amp;lt; 5; i++ {
fmt.Println(scanner.Text())
}
if err := scanner.Err(); err != nil {
log.Println(err)
}
}
&lt;/code>&lt;/pre>
&lt;p>And make sure it is called from the get command:&lt;/p>
&lt;pre>&lt;code class="language-go"> Run: func(cmd *cobra.Command, args []string) {
get()
},
&lt;/code>&lt;/pre>
&lt;p>Rebuild and start the server:&lt;/p>
&lt;pre>&lt;code class="language-bash">go build
./hello serve
&lt;/code>&lt;/pre>
&lt;p>Then from another console window:&lt;/p>
&lt;pre>&lt;code class="language-bash">./hello get
&lt;/code>&lt;/pre>
&lt;p>And you will see the hello as output!&lt;/p>
&lt;h3 id="add-a-flag">Add a Flag&lt;/h3>
&lt;p>To finish up, let&amp;rsquo;s add a flag to specify the port number that our server will listen on.&lt;/p>
&lt;p>We&amp;rsquo;ll keep it simple for now, we want:&lt;/p>
&lt;ul>
&lt;li>Works for both the client and the server&lt;/li>
&lt;li>Supports the full &amp;ndash;port and the shorthand -p&lt;/li>
&lt;li>Default port is 80&lt;/li>
&lt;/ul>
&lt;p>In &lt;em>get&lt;/em>.go_, declare a variable to be used as port number:&lt;/p>
&lt;pre>&lt;code class="language-go">var clientPort int
&lt;/code>&lt;/pre>
&lt;p>And add the port flag to the &lt;em>init()&lt;/em> function:&lt;/p>
&lt;pre>&lt;code class="language-go"> getCmd.Flags().IntVarP(&amp;amp;clientPort,&amp;quot;port&amp;quot;,&amp;quot;p&amp;quot;, 80, &amp;quot;port number&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>Do the same thing in &lt;em>serve.go&lt;/em>, but use serverPort as variable name.&lt;/p>
&lt;p>Rebuild and check the help output:&lt;/p>
&lt;pre>&lt;code class="language-bash">go build
./hello
./hello serve -h
./hello get -h
&lt;/code>&lt;/pre>
&lt;p>Let&amp;rsquo;s adjust the server so it uses the new port flag.
In the &lt;em>listen()&lt;/em> function in &lt;em>serve.go&lt;/em>, replace&lt;/p>
&lt;pre>&lt;code class="language-go"> err = http.ListenAndServe(&amp;quot;:80&amp;quot;, nil)
&lt;/code>&lt;/pre>
&lt;p>with&lt;/p>
&lt;pre>&lt;code class="language-go"> log.Printf(&amp;quot;Listening on port %d\n&amp;quot;, serverPort)
err = http.ListenAndServe(fmt.Sprintf(&amp;quot;:%d&amp;quot;, serverPort), nil)
&lt;/code>&lt;/pre>
&lt;p>Now for the client, in the &lt;em>get()&lt;/em> function in &lt;em>get.go&lt;/em>, replace&lt;/p>
&lt;pre>&lt;code class="language-go"> resp, err := http.Get(&amp;quot;http://localhost&amp;quot;)
&lt;/code>&lt;/pre>
&lt;p>with&lt;/p>
&lt;pre>&lt;code class="language-go"> resp, err := http.Get(fmt.Sprintf(&amp;quot;http://localhost:%d&amp;quot;, clientPort))
&lt;/code>&lt;/pre>
&lt;p>Rebuild and start the server:&lt;/p>
&lt;pre>&lt;code class="language-bash">go build
./hello serve -p 10080
&lt;/code>&lt;/pre>
&lt;p>The server will now be available on &lt;a href="http://localhost:10080" target="_blank" rel="noopener">http://localhost:10080&lt;/a>&lt;/p>
&lt;p>Then from another console window:&lt;/p>
&lt;pre>&lt;code class="language-bash">./hello get -p 10080
&lt;/code>&lt;/pre>
&lt;p>You should see something similar to:
Then from another console window:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">Go Hello 1 from my-mac.home on GET ./
&lt;/code>&lt;/pre>
&lt;h3 id="the-code">The code&lt;/h3>
&lt;p>The code of my simple Hello Server is available on GitHub &lt;a href="https://github.com/akleinloog/hello" target="_blank" rel="noopener">here&lt;/a>.
I may add a few features there since I intend to use it for some Kubernetes experiments.
Another similar example is my simple &lt;a href="https://www.kleinloog.ch/project/http-logger">HTTP Logger&lt;/a>.&lt;/p></description></item><item><title>Minikube - Kubernetes for developers</title><link>https://www.kleinloog.ch/post/minikube-kubernetes/</link><pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/post/minikube-kubernetes/</guid><description>&lt;p>As described &lt;a href="https://www.kleinloog.ch/post/which-local-kubernetes">here&lt;/a>, I decided to take a deeper look at &lt;a href="https://minikube.sigs.k8s.io/docs/" target="_blank" rel="noopener">minikube&lt;/a> to run a Kubernetes cluster on my dev machine.
These are the details and some of my learnings along the way.&lt;/p>
&lt;h3 id="preparation">Preparation&lt;/h3>
&lt;p>As usual, before starting any experiments, I want my MacBook up to date, so I make sure that I have the latest updates installed.
At the time of writing, these are macOS Catalina version 10.15.5 and Xcode version 11.5.
Then I make sure that brew and any installed packages are up to date as well:&lt;/p>
&lt;pre>&lt;code class="language-bash">brew update
brew upgrade
brew cask upgrade
&lt;/code>&lt;/pre>
&lt;p>In addition, make sure there are no issues. If there are, resolve them first:&lt;/p>
&lt;pre>&lt;code class="language-bash">brew doctor
&lt;/code>&lt;/pre>
&lt;p>Should give the following output when all is ready:&lt;/p>
&lt;pre>&lt;code class="language-bash">Your system is ready to brew.
&lt;/code>&lt;/pre>
&lt;p>Should you run into any issues, google is your friend&amp;hellip;&lt;/p>
&lt;p>If you are running windows, &lt;a href="https://chocolatey.org/" target="_blank" rel="noopener">chocolatey&lt;/a> is a decent alternative to brew.&lt;/p>
&lt;p>If not already installed, make sure you have &lt;a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">Docker Desktop&lt;/a> up and running.
This should also come with &lt;a href="https://github.com/moby/hyperkit" target="_blank" rel="noopener">Hyperkit&lt;/a>, a lightweight hypervisor for macOS.
You can find other alternatives &lt;a href="https://minikube.sigs.k8s.io/docs/drivers/" target="_blank" rel="noopener">here&lt;/a>.&lt;/p>
&lt;h3 id="installation">Installation&lt;/h3>
&lt;p>Install minikube and &lt;a href="https://kubernetes.io/docs/reference/kubectl/overview/" target="_blank" rel="noopener">kubectl&lt;/a>:&lt;/p>
&lt;pre>&lt;code class="language-bash">brew install minikube
brew install kubectl
&lt;/code>&lt;/pre>
&lt;h3 id="first-cluster">First Cluster&lt;/h3>
&lt;p>Create a cluster:&lt;/p>
&lt;pre>&lt;code class="language-bash">minikube start
&lt;/code>&lt;/pre>
&lt;p>Gives an output similar to:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">ðŸ˜„ minikube v1.11.0 on Darwin 10.15.5
âœ¨ Using the hyperkit driver based on user configuration
ðŸ†• Kubernetes 1.18.3 is now available. If you would like to upgrade, specify: --kubernetes-version=v1.18.3
ðŸ‘ Starting control plane node minikube in cluster minikube
ðŸ”¥ Creating hyperkit VM (CPUs=2, Memory=2048MB, Disk=20000MB) ...
ðŸ³ Preparing Kubernetes v1.14.7 on Docker 19.03.8 ...
ðŸ”Ž Verifying Kubernetes components...
ðŸŒŸ Enabled addons: default-storageclass, storage-provisioner
ðŸ„ Done! kubectl is now configured to use &amp;quot;minikube&amp;quot;
â— /usr/local/bin/kubectl is version 1.18.3, which may be incompatible with Kubernetes 1.14.7.
ðŸ’¡ You can also use 'minikube kubectl -- get pods' to invoke a matching version
&lt;/code>&lt;/pre>
&lt;p>This tells us that the default Kubernetes version that was used is &lt;strong>1.14.7&lt;/strong>, and that the cluster has &lt;strong>2&lt;/strong> CPUs, &lt;strong>2 GB&lt;/strong> of memory and &lt;strong>20 GB&lt;/strong> of disk spaces at its disposable.
It also tells us that the latest available version of Kubernetes is &lt;strong>1.18.3&lt;/strong>.
Since this is my dev machine, I want to use the latest Kubernetes version, and I want to assign more resources.
Remove the cluster:&lt;/p>
&lt;pre>&lt;code class="language-bash">minikube delete
&lt;/code>&lt;/pre>
&lt;p>Gives an output similar to:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">ðŸ”¥ Deleting &amp;quot;minikube&amp;quot; in hyperkit ...
ðŸ’€ Removed all traces of the &amp;quot;minikube&amp;quot; cluster.
&lt;/code>&lt;/pre>
&lt;p>Create a new cluster as follows:&lt;/p>
&lt;pre>&lt;code class="language-bash">minikube start --kubernetes-version=v1.18.3 --cpus=4 --memory='8g' --disk-size='80000mb'
&lt;/code>&lt;/pre>
&lt;p>Gives an output similar to:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">ðŸ˜„ minikube v1.11.0 on Darwin 10.15.5
âœ¨ Using the hyperkit driver based on user configuration
ðŸ‘ Starting control plane node minikube in cluster minikube
ðŸ”¥ Creating hyperkit VM (CPUs=4, Memory=8192MB, Disk=80000MB) ...
ðŸ³ Preparing Kubernetes v1.18.3 on Docker 19.03.8 ...
ðŸ”Ž Verifying Kubernetes components...
ðŸŒŸ Enabled addons: default-storageclass, storage-provisioner
ðŸ„ Done! kubectl is now configured to use &amp;quot;minikube&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>That is more like it. A local Kubernetes cluster up and running, and everything is up to date.
If you want, you can open the kubernetes dashboard using:&lt;/p>
&lt;pre>&lt;code class="language-bash">minikube dashboard
&lt;/code>&lt;/pre>
&lt;p>The dashboard will be installed and opened in a browser tab.&lt;/p>
&lt;h3 id="pause-and-resume">Pause and resume&lt;/h3>
&lt;p>One very useful feature of minikube is that you can pause and resume your cluster.
If you don&amp;rsquo;t need it for now, pause the cluster using:&lt;/p>
&lt;pre>&lt;code class="language-bash">minikube stop
&lt;/code>&lt;/pre>
&lt;p>Gives an output similar to:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">âœ‹ Stopping &amp;quot;minikube&amp;quot; in hyperkit ...
ðŸ›‘ Node &amp;quot;minikube&amp;quot; stopped.
&lt;/code>&lt;/pre>
&lt;p>At a later point, you can resume it using:&lt;/p>
&lt;pre>&lt;code class="language-bash">minikube start --kubernetes-version=v1.18.3
&lt;/code>&lt;/pre>
&lt;p>Gives an output similar to:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">ðŸ˜„ minikube v1.11.0 on Darwin 10.15.5
âœ¨ Using the hyperkit driver based on existing profile
ðŸ‘ Starting control plane node minikube in cluster minikube
ðŸ”„ Restarting existing hyperkit VM for &amp;quot;minikube&amp;quot; ...
ðŸ³ Preparing Kubernetes v1.18.3 on Docker 19.03.8 ...
ðŸ”Ž Verifying Kubernetes components...
ðŸŒŸ Enabled addons: default-storageclass, storage-provisioner
ðŸ„ Done! kubectl is now configured to use &amp;quot;minikube&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Notice that you do need to provide the Kubernetes version if you specified one different from the default.
This command can also be used to upgrade the Kubernetes version if a newer one becomes available.&lt;/p>
&lt;h3 id="multiple-clusters">Multiple Clusters&lt;/h3>
&lt;p>Another very useful feature of minikube is the ability to run multiple clusters.
You can run them at the same time to do multi-cluster experiments, or pause / resume them when switching between projects.
Let&amp;rsquo;s first delete the previously created cluster:&lt;/p>
&lt;pre>&lt;code class="language-bash">minikube delete
&lt;/code>&lt;/pre>
&lt;p>Then create our first cluster:&lt;/p>
&lt;pre>&lt;code class="language-bash">minikube start -p cluster1 --kubernetes-version=v1.18.3
&lt;/code>&lt;/pre>
&lt;p>And then a second one:&lt;/p>
&lt;pre>&lt;code class="language-bash">minikube start -p cluster2 --kubernetes-version=v1.18.3
&lt;/code>&lt;/pre>
&lt;p>You can see the clusters using:&lt;/p>
&lt;pre>&lt;code class="language-bash">kubectl config get-contexts
&lt;/code>&lt;/pre>
&lt;p>Gives an output similar to:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">CURRENT NAME CLUSTER AUTHINFO NAMESPACE
cluster1 cluster1 cluster1
* cluster2 cluster2 cluster2
&lt;/code>&lt;/pre>
&lt;p>The * marks the currently selected context. You can also see that using:&lt;/p>
&lt;pre>&lt;code class="language-bash">% kubectl config current-context
cluster2
&lt;/code>&lt;/pre>
&lt;p>You can switch between clusters by selecting their context:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">% kubectl config use-context cluster1
Switched to context &amp;quot;cluster1&amp;quot;.
&lt;/code>&lt;/pre>
&lt;p>Stop one of the clusters if you don&amp;rsquo;t need it for now:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">% minikube stop -p cluster2
âœ‹ Stopping &amp;quot;cluster2&amp;quot; in hyperkit ...
ðŸ›‘ Node &amp;quot;cluster2&amp;quot; stopped.
&lt;/code>&lt;/pre>
&lt;p>Resume it when you need it again:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">% minikube start -p cluster2 --kubernetes-version=v1.18.3
ðŸ˜„ [cluster2] minikube v1.11.0 on Darwin 10.15.5
âœ¨ Using the hyperkit driver based on existing profile
ðŸ‘ Starting control plane node cluster2 in cluster cluster2
ðŸ”„ Restarting existing hyperkit VM for &amp;quot;cluster2&amp;quot; ...
ðŸ³ Preparing Kubernetes v1.18.3 on Docker 19.03.8 ...
ðŸ”Ž Verifying Kubernetes components...
ðŸŒŸ Enabled addons: default-storageclass, storage-provisioner
ðŸ„ Done! kubectl is now configured to use &amp;quot;cluster2&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>And delete it when you don&amp;rsquo;t need it anymore:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">% minikube delete -p cluster2
ðŸ”¥ Deleting &amp;quot;cluster2&amp;quot; in hyperkit ...
ðŸ’€ Removed all traces of the &amp;quot;cluster2&amp;quot; cluster.
&lt;/code>&lt;/pre>
&lt;h3 id="next-steps">Next Steps&amp;hellip;&lt;/h3>
&lt;p>Get more familiar with Kubernetes, follow some basic tutorials to deploy your first app &lt;a href="https://kubernetes.io/docs/tutorials/" target="_blank" rel="noopener">here&lt;/a> and find some more &lt;a href="https://katacoda.com/courses/kubernetes" target="_blank" rel="noopener">here&lt;/a>. Again, google is your friend, there is plenty of content out there.&lt;/p>
&lt;p>As for me, my next step will be to install &lt;a href="https://istio.io/" target="_blank" rel="noopener">Istio&lt;/a> and make sure that my cluster can also be reached from other machines in my network.
I&amp;rsquo;ll present the details in a following post&amp;hellip;&lt;/p></description></item><item><title>Rapid API Prototyping</title><link>https://www.kleinloog.ch/post/rapid-api-prototype/</link><pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/post/rapid-api-prototype/</guid><description>&lt;p>The goal of my &lt;a href="https://www.kleinloog.ch/project/rapid-api">Rapid API project&lt;/a> is to create a containerized starting point that can be used to quickly implement a prototype of an API, customize it as needed, and easily add initial content.&lt;/p>
&lt;h2 id="preparation">Preparation&lt;/h2>
&lt;p>To get started, create a new GitHub repository, initialized it with a README and a license, and clone it to your local machine.&lt;/p>
&lt;h2 id="docker-files">Docker files&lt;/h2>
&lt;p>Add a &lt;em>docker-compose.yaml&lt;/em> file with the following content:&lt;/p>
&lt;pre>&lt;code class="language-yaml">version: '3.7'
services:
rapid-api:
container_name: api-dev
build: ./docker/sqlite
ports:
- '8080:8080'
&lt;/code>&lt;/pre>
&lt;p>This file points to a Dockerfile in the &lt;em>/docker/sqlite&lt;/em> folder and maps container port 8080 to host port 8080 so we can access our API.&lt;/p>
&lt;p>Next, add a &lt;em>docker&lt;/em> folder with a &lt;em>sqlite&lt;/em> sub folder. There, create a &lt;em>Dockerfile&lt;/em> with the following content:&lt;/p>
&lt;pre>&lt;code class="language-dockerfile">FROM node:13.14.0-alpine3.11
RUN apk update &amp;amp;&amp;amp; apk upgrade
RUN yarn global add strapi
WORKDIR /app
RUN strapi new . --quickstart --no-run
RUN yarn install --force
RUN strapi install documentation &amp;amp;&amp;amp; strapi install graphql
RUN sed -i 's/1337/8080/g' ./config/server.js
COPY settings.json /app/extensions/documentation/config/
COPY entrypoint.sh /usr/local/bin/
RUN chmod 755 &amp;quot;/usr/local/bin/entrypoint.sh&amp;quot;
EXPOSE 8080
ENTRYPOINT [&amp;quot;/usr/local/bin/entrypoint.sh&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>As you can see, the Dockerfile uses the latest Node JS 13 version.
At the time of writing, Node JS 14 has already been released, but not all of strapi&amp;rsquo;s dependencies were available at the time of writing.&lt;/p>
&lt;p>The docker build starts with installing the strapi CLI, which it then uses to create a new quickstart project.
This initializes a strapi project using a &lt;a href="https://www.sqlite.org/index.html" target="_blank" rel="noopener">SQLite&lt;/a> database.
It then installs the &lt;a href="https://strapi.io/documentation/v3.x/plugins/documentation.html" target="_blank" rel="noopener">API documentation&lt;/a> and &lt;a href="https://strapi.io/documentation/v3.x/plugins/graphql.html" target="_blank" rel="noopener">GraphQL&lt;/a> plugins and changes the default port number from 1337 to 8080.
In addition, it copies a &lt;em>settings.json&lt;/em> file and an &lt;em>entrypoint.sh&lt;/em> file to the image.&lt;/p>
&lt;h2 id="open-api-settings">Open API settings&lt;/h2>
&lt;p>Next to the &lt;em>Dockerfile&lt;/em> in the &lt;em>sqlite&lt;/em> folder, add a &lt;em>settings.json&lt;/em> file with the following content:&lt;/p>
&lt;pre>&lt;code class="language-json">{
&amp;quot;openapi&amp;quot;: &amp;quot;3.0.0&amp;quot;,
&amp;quot;info&amp;quot;: {
&amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
&amp;quot;title&amp;quot;: &amp;quot;DOCUMENTATION&amp;quot;,
&amp;quot;description&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;termsOfService&amp;quot;: &amp;quot;YOUR_TERMS_OF_SERVICE_URL&amp;quot;,
&amp;quot;contact&amp;quot;: {
&amp;quot;name&amp;quot;: &amp;quot;TEAM&amp;quot;,
&amp;quot;email&amp;quot;: &amp;quot;contact-email@something.io&amp;quot;,
&amp;quot;url&amp;quot;: &amp;quot;mywebsite.io&amp;quot;
},
&amp;quot;license&amp;quot;: {
&amp;quot;name&amp;quot;: &amp;quot;Apache 2.0&amp;quot;,
&amp;quot;url&amp;quot;: &amp;quot;https://www.apache.org/licenses/LICENSE-2.0.html&amp;quot;
}
},
&amp;quot;x-strapi-config&amp;quot;: {
&amp;quot;path&amp;quot;: &amp;quot;/documentation&amp;quot;,
&amp;quot;showGeneratedFiles&amp;quot;: true,
&amp;quot;pluginsForWhichToGenerateDoc&amp;quot;: [
&amp;quot;email&amp;quot;,
&amp;quot;upload&amp;quot;,
&amp;quot;users-permissions&amp;quot;
]
},
&amp;quot;servers&amp;quot;: [
{
&amp;quot;url&amp;quot;: &amp;quot;http://localhost:8080&amp;quot;,
&amp;quot;description&amp;quot;: &amp;quot;Development server&amp;quot;
},
{
&amp;quot;url&amp;quot;: &amp;quot;YOUR_STAGING_SERVER&amp;quot;,
&amp;quot;description&amp;quot;: &amp;quot;Staging server&amp;quot;
},
{
&amp;quot;url&amp;quot;: &amp;quot;YOUR_PRODUCTION_SERVER&amp;quot;,
&amp;quot;description&amp;quot;: &amp;quot;Production server&amp;quot;
}
],
&amp;quot;externalDocs&amp;quot;: {
&amp;quot;description&amp;quot;: &amp;quot;Find out more&amp;quot;,
&amp;quot;url&amp;quot;: &amp;quot;https://strapi.io/documentation/&amp;quot;
},
&amp;quot;security&amp;quot;: [
{
&amp;quot;bearerAuth&amp;quot;: []
}
],
&amp;quot;paths&amp;quot;: {},
&amp;quot;tags&amp;quot;: [],
&amp;quot;components&amp;quot;: {}
}
&lt;/code>&lt;/pre>
&lt;p>This file is needed in order to correct the port number used by the Open API endpoint. Feel free to edit the other settings to your liking.
For more info, see &lt;a href="https://strapi.io/documentation/v3.x/plugins/documentation.html#installation" target="_blank" rel="noopener">this section&lt;/a> in the strapi documentation.&lt;/p>
&lt;h2 id="entrypoint">Entrypoint&lt;/h2>
&lt;p>Next to the &lt;em>Dockerfile&lt;/em> in the &lt;em>sqlite&lt;/em> folder, add an &lt;em>entrypoint.sh&lt;/em> file with the following content:&lt;/p>
&lt;pre>&lt;code class="language-bash">#!/bin/sh
# exit when any command fails
set -e
echo &amp;quot;Starting Server&amp;quot;
strapi develop
&lt;/code>&lt;/pre>
&lt;p>This entrypoint script simply starts the strapi project in development mode, with automatic reload enabled.&lt;/p>
&lt;h2 id="first-run">First run&lt;/h2>
&lt;p>Startup the container for the first time:&lt;/p>
&lt;pre>&lt;code class="language-bash">docker-compose up --build
&lt;/code>&lt;/pre>
&lt;p>It will take a while before we are ready for the next steps. The base image is downloaded, updates are installed, the strapi project is initialized and the Documentation and GraphQL plugins are installed. Once this is completed, the container is started and some log entries appear.
Eventually you will see something like this, indicating that the container is successfully started:&lt;/p>
&lt;pre>&lt;code class="language-plaintext">api-dev | One more thing...
api-dev | Create your first administrator ðŸ’» by going to the administration panel at:
api-dev |
api-dev | â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
api-dev | â”‚ http://localhost:8080/admin â”‚
api-dev | â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
api-dev |
&lt;/code>&lt;/pre>
&lt;p>You are now read to navigate to &lt;a href="http://localhost:8080/admin" target="_blank" rel="noopener">http://localhost:8080/admin&lt;/a>, create an admin account and start customizing your API.&lt;/p>
&lt;h2 id="adding-content">Adding Content&lt;/h2>
&lt;p>Let&amp;rsquo;s add a first example resource together.&lt;/p>
&lt;p>From the menu on the left, select the &lt;em>Content-Types Builder&lt;/em> and choose &lt;em>Create new collection type&lt;/em>.
Give it a display name &lt;em>Example&lt;/em> and continue. Now we can add our choice of fields to our collection type:
&lt;img src="fields.png" alt="Content Fields">
As you can see, strapi comes with a nice set of built-in field types. Feel free to experiment with them.
For now, we will just add a Text field called &lt;em>Name&lt;/em> and a Rich Text field called &lt;em>Description&lt;/em>.
Hit &lt;em>Finish&lt;/em> and then &lt;em>Save&lt;/em>. Strapi will now generate the &lt;em>Example API&lt;/em> and restart the server.
Once complete, you will see the &lt;em>Example&lt;/em> collection type appear in the top left.
Open it up and add a few examples.&lt;/p>
&lt;p>Checkout the &lt;a href="https://strapi.io/documentation/v3.x/getting-started/introduction.html" target="_blank" rel="noopener">strapi documentation&lt;/a> and &lt;a href="https://strapi.io/tutorials" target="_blank" rel="noopener">tutorials&lt;/a> for more examples.&lt;/p>
&lt;h2 id="test-the-api">Test the API&lt;/h2>
&lt;p>Now that we have added some content and created our first API, we want to see it in action.
You can use the API client of your choice to test it (postman, &lt;a href="https://insomnia.rest/" target="_blank" rel="noopener">insomnia&lt;/a>, curl, etc,)
At the moment, I prefer to use Visual Studio Code with the &lt;a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" target="_blank" rel="noopener">REST Client&lt;/a> plugin.
Add a &lt;em>test.http&lt;/em> file with the first test:&lt;/p>
&lt;pre>&lt;code class="language-http">###
GET http://localhost:8080/examples
&lt;/code>&lt;/pre>
&lt;p>A little &lt;em>Send Request&lt;/em> label will appear, and when you click that, Visual Studio Code will execute the GET request.
You will get a response like this:&lt;/p>
&lt;pre>&lt;code class="language-http">HTTP/1.1 403 Forbidden
...
Connection: close
{
&amp;quot;statusCode&amp;quot;: 403,
&amp;quot;error&amp;quot;: &amp;quot;Forbidden&amp;quot;,
&amp;quot;message&amp;quot;: &amp;quot;Forbidden&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>Your API supports authentication and is not open to the public!
For the sake of this test, in your strapi Admin UI, navigate to &lt;em>Roles &amp;amp; Responsibilities&lt;/em>, select &lt;em>Public&lt;/em> and check &lt;em>Select All&lt;/em> next to &lt;em>Example&lt;/em> and save that.
&lt;img src="permissions.png" alt="Permissions">&lt;/p>
&lt;p>Now try sending the request again, you should receive the examples that you&amp;rsquo;ve added previously.&lt;/p>
&lt;p>For our last exercise, let&amp;rsquo;s use the API to add another entry.
Add the following to the &lt;em>test.http&lt;/em> file:&lt;/p>
&lt;pre>&lt;code class="language-http">###
POST http://localhost:8080/examples
content-type: application/json
{
&amp;quot;name&amp;quot;: &amp;quot;API Example&amp;quot;,
&amp;quot;description&amp;quot;: &amp;quot;Added using the API&amp;quot;
}
&lt;/code>&lt;/pre>
&lt;p>Don&amp;rsquo;t forget the content-type header! Strapi will check for this and create an entry with empty values if you forget to specify that!&lt;/p>
&lt;h2 id="api-documentation">API Documentation&lt;/h2>
&lt;p>You will find another nice feature of our setup when you navigate to &lt;em>Documentation&lt;/em>. Click in the &lt;em>Retrieve your jwt token&lt;/em> textbox and the token will be copied to the clipboard. Click on &lt;em>Open the documentation&lt;/em> and the Swagger based OpenAPI endpoint will be opened. You can &lt;em>Authorize&lt;/em> yourself with your token and get familiar with all the options that your API has to offer.&lt;/p>
&lt;h2 id="graphql">GraphQL&lt;/h2>
&lt;p>A main reason for me to try strapi for rapid API prototyping is its support for GraphQL.
I am not yet very familiar with GraphQL and want to have a playground to learn more.&lt;/p>
&lt;p>Your API&amp;rsquo;s GraphQL Playground is available at &lt;a href="http://localhost:8080/graphql" target="_blank" rel="noopener">http://localhost:8080/graphql&lt;/a>. See &lt;a href="https://strapi.io/documentation/v3.x/plugins/graphql.html" target="_blank" rel="noopener">this section&lt;/a> in the strapi documentation for more info.&lt;/p>
&lt;h2 id="even-easier">Even easier&amp;hellip;&lt;/h2>
&lt;p>Don&amp;rsquo;t want to go through the effort described above?
I&amp;rsquo;ll do you one better. The resulting container image is available &lt;a href="https://hub.docker.com/r/akleinloog/rapid-api" target="_blank" rel="noopener">here&lt;/a> on docker hub, so you can get started with a single line:&lt;/p>
&lt;pre>&lt;code class="language-bash">docker run -p 8080:8080 akleinloog/rapid-api
&lt;/code>&lt;/pre>
&lt;h2 id="the-code">The code&lt;/h2>
&lt;p>If you want to see how to set up a prototype using MongoDB instead of SQLite, or wonder how I built and published the container image to docker hub, feel free to check out the &lt;a href="https://github.com/akleinloog/rapid-api" target="_blank" rel="noopener">repository&lt;/a> on Github.&lt;/p></description></item><item><title>HTTP Logger</title><link>https://www.kleinloog.ch/project/http-logger/</link><pubDate>Fri, 22 May 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/project/http-logger/</guid><description>&lt;p>This goal of this project is to create a simple HTTP Logger in Go, that logs all incoming HTTP requests in a structured way.&lt;/p>
&lt;h2 id="the-what">The What&lt;/h2>
&lt;p>A Simple HTTP Logger that can be configured to run on any port.&lt;/p>
&lt;p>My main requirements:&lt;/p>
&lt;ul>
&lt;li>Log HTTP GET, POST, PUT and other methods to stdout&lt;/li>
&lt;li>Always return 200 OK as response&lt;/li>
&lt;li>Structured logging in JSON format&lt;/li>
&lt;li>Log Host, URL, Method, IP addresses, request body and more&lt;/li>
&lt;li>Containerized, lightweight, easily usable in different environments&lt;/li>
&lt;/ul>
&lt;p>Additional nice to haves:&lt;/p>
&lt;ul>
&lt;li>Enforce SSL with redirect and correct certificates&lt;/li>
&lt;li>Easy configuration (flags, environment settings, config files)&lt;/li>
&lt;li>Easy way to access request body&lt;/li>
&lt;/ul>
&lt;h2 id="the-why">The Why&lt;/h2>
&lt;p>The HTTP Logger can be used to gain some insights into HTTP traffic, for example, when you want to test if a webhook is properly sending messages, and what the content of these messages is.&lt;/p>
&lt;p>In addition, it is a perfectly small Microservice, ideally suited to learn some Go development practices that could be suited for other Microservices too.&lt;/p>
&lt;h2 id="the-how">The How&lt;/h2>
&lt;p>The HTTP Logger will be implemented using Go, a language that I am not yet familiar with, but really want to learn.
And for me, the best way to learn after some basic tutorials is to put things into practice.&lt;/p>
&lt;p>In order to learn a bit more about Go, I will pay attention to:&lt;/p>
&lt;ul>
&lt;li>Structured Logging (stdout in JSON)&lt;/li>
&lt;li>Flexible Configuration (Support for Flags, Environment, Config file, etx)&lt;/li>
&lt;li>Proper CLI support&lt;/li>
&lt;/ul>
&lt;h2 id="the-results">The Results&lt;/h2>
&lt;p>I just started this project, so there are no results to share just yet.
I will detail the progress in a series of blog posts and update this section when the HTTP Logger is available.&lt;/p>
&lt;p>In the end, my solution will be publicly available on GitHub and on Docker, for you to use freely, to learn from, and hopefully, to provide some feedback on!&lt;/p></description></item><item><title>Kubernetes on my machine. Great idea, but which one?</title><link>https://www.kleinloog.ch/post/which-local-kubernetes/</link><pubDate>Fri, 22 May 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/post/which-local-kubernetes/</guid><description>&lt;p>&lt;a href="https://kubernetes.io" target="_blank" rel="noopener">Kubernetes&lt;/a> is the state-of-the-art when it comes to container orchestration.&lt;br>
Built upon years of experience with production workloads at Google, it combines best-of-breed ideas and community practices.
Kubernetes is a classroom example of a successful open source project, drives vendor neutrality and runs basically everywhere.&lt;/p>
&lt;p>Today, I see Kubernetes as the operating system of the Cloud Native world.
It is the base environment for my containerized applications, so I need to have it up and running locally on my development notebook.&lt;/p>
&lt;p>Luckily there are several decent options. All I need to do is choose one.&lt;/p>
&lt;h3 id="my-requirements">My Requirements&lt;/h3>
&lt;p>As always, choosing a solution works best if you understand your needs.
Since this is for my local development environment, my must haves are:&lt;/p>
&lt;ul>
&lt;li>Lightweight, tuns on my laptop&lt;/li>
&lt;li>Easy to install, configure and automate&lt;/li>
&lt;li>Wide support of Kubernetes versions and features&lt;/li>
&lt;li>Cross Platform, available for Mac, Windows and Linux&lt;/li>
&lt;/ul>
&lt;p>In addition, I would like to use the same solution on a development server to create a one node cluster.
Ideally, I should be able to use it with some Raspberry Pis to create a small cluster as well.
These are nice to haves though, using a different distribution for each purpose is an option too.&lt;/p>
&lt;h3 id="the-alternatives">The Alternatives&lt;/h3>
&lt;p>So far, I have identified the following solutions as promising:&lt;/p>
&lt;p>&lt;a href="https://www.docker.com/blog/kubernetes-is-now-available-in-docker-desktop-stable-channel/" target="_blank" rel="noopener">Docker Desktop&lt;/a> ships with a bundled Kubernetes offering.
The Kubernetes version it supports is tightly coupled with the Docker version. The current version (2.4.0.0) ships with Kubernetes version 1.18.8.
Since it comes with docker I don&amp;rsquo;t need to install anything. At the same time, I did not find an easy programmatic way to create and destroy a new Kubernetes cluster.&lt;/p>
&lt;p>&lt;a href="https://kind.sigs.k8s.io" target="_blank" rel="noopener">Kind&lt;/a> - Kubernetes IN Docker - is a tool for running local Kubernetes clusters using Docker containers as nodes.
It is an &lt;a href="https://github.com/kubernetes-sigs/kind" target="_blank" rel="noopener">open source&lt;/a> project managed by the Kubernetes Community and was primarily designed for testing Kubernetes itself.
Kind supports multi-node (including HA) clusters and is optimized for CI pipelines.&lt;/p>
&lt;p>&lt;a href="https://minikube.sigs.k8s.io/docs/" target="_blank" rel="noopener">Minikube&lt;/a> sets up a local single node Kubernetes cluster using a VM.
It is another &lt;a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">open source&lt;/a> project managed by the Kubernetes Community and was designed to make it simple to run Kubernetes locally, for day-to-day development workflows and learning purposes.
Minikube supports multiple container runtimes and advanced features such as load balancer, filesystem mounts, and feature gates.&lt;/p>
&lt;p>&lt;a href="https://k3d.io" target="_blank" rel="noopener">K3d&lt;/a> is a lightweight wrapper to run &lt;a href="https://k3s.io" target="_blank" rel="noopener">k3s&lt;/a>, Rancher Labâ€™s minified Kubernetes distribution, in docker.
By removing dispensable features (legacy, alpha, non-default, in-tree plugins) and using lightweight components (e.g. sqlite3 instead of etcd3) Rancher Labs created an ultra small Kubernetes distribution built for IoT and Edge computing. It supports ARMv7 and ARM64 architectures, making it possible to run a Kubernetes cluster on a set of Raspberry Pis.&lt;/p>
&lt;p>Last but not least, &lt;a href="https://microk8s.io" target="_blank" rel="noopener">MicroK8s&lt;/a> is a production-grade Kubernetes distribution maintained by Canonical.
MicroK8s runs in an immutable container, comes with a range of sensible defaults to ease installation and configuration.
Networking, storage and standard services are supported out of the box and can be customized as needed.
It supports both ARM and Intel architectures, as well as single node and multi node deployments.&lt;/p>
&lt;p>Of course there are other potential alternatives like &lt;a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" target="_blank" rel="noopener">Kubeadm&lt;/a>, &lt;a href="https://kubespray.io" target="_blank" rel="noopener">Kubespray&lt;/a>, &lt;a href="https://kops.sigs.k8s.io" target="_blank" rel="noopener">Kops&lt;/a> and more. I discarded these because they are not cross platform, require too much manual configuration or are rather geared towards production environments.&lt;/p>
&lt;p>If you feel there is an alternative missing here, please leave a comment.&lt;/p>
&lt;h3 id="how-do-they-compare">How do they compare?&lt;/h3>
&lt;p>The following table lists the alternatives along with some of their characteristics:&lt;/p>
&lt;ul>
&lt;li>Nodes: The number of cluster nodes supported&lt;/li>
&lt;li>CLI: Supports automated installation and configuration&lt;/li>
&lt;li>Multiple: Supports multiple clusters on a single machine&lt;/li>
&lt;li>Versions: Support for different Kubernetes versions&lt;/li>
&lt;li>Features: Support for Kubernetes features&lt;/li>
&lt;li>Resources: Resource usage when compare to each other&lt;/li>
&lt;li>Pauseable: Cluster can be stopped and restarted&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Nodes&lt;/th>
&lt;th>CLI&lt;/th>
&lt;th>Multiple&lt;/th>
&lt;th>Versions&lt;/th>
&lt;th>Features&lt;/th>
&lt;th>Resources&lt;/th>
&lt;th>Pauseable&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>MicroK8s&lt;/td>
&lt;td>n&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Medium&lt;/td>
&lt;td>Highest&lt;/td>
&lt;td>Low&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Minikube&lt;/td>
&lt;td>1&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>High&lt;/td>
&lt;td>Highest&lt;/td>
&lt;td>High&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kind&lt;/td>
&lt;td>n&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>High&lt;/td>
&lt;td>High&lt;/td>
&lt;td>Medium&lt;/td>
&lt;td>No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>K3d&lt;/td>
&lt;td>n&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Yes&lt;/td>
&lt;td>Low&lt;/td>
&lt;td>Medium&lt;/td>
&lt;td>Low&lt;/td>
&lt;td>No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Docker&lt;/td>
&lt;td>1&lt;/td>
&lt;td>No&lt;/td>
&lt;td>No&lt;/td>
&lt;td>Single&lt;/td>
&lt;td>High&lt;/td>
&lt;td>Medium&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="conclusion">Conclusion&lt;/h3>
&lt;p>This exercise provided me with some interesting insights.&lt;/p>
&lt;p>I won&amp;rsquo;t be using the Docker Desktop version, mainly because it only supports a single Kubernetes version and I haven&amp;rsquo;t found a way to programmatically create, configure and destroy the cluster.&lt;/p>
&lt;p>Running a Kubernetes cluster on a set of Raspberry Pis is definitely something I want to spend some time on.
With two options to try out I can&amp;rsquo;t wait to get started. I&amp;rsquo;ll add a post as soon as I get to it.&lt;/p>
&lt;p>Both Kind and Minikube are interesting options managed by the Kubernetes community.
They have done an awesome job with Kubernetes, so I expect these to be hassle free alternatives.
At first sight, Kind seems to be promising for automated tests in your CI/CD pipeline and Minikube seems to be the most feature rich for your desktop.&lt;/p>
&lt;p>I took a deeper look at Minikube, see this &lt;a href="https://www.kleinloog.ch/post/minikube-kubernetes">post&lt;/a> for the details.&lt;/p>
&lt;p>Up next is MicroK8s, more on that to follow soon.&lt;/p>
&lt;p>&lt;a href="https://docs.google.com/spreadsheets/d/1LxSqBzjOxfGx3cmtZ4EbB_BGCxT_wlxW_xgHVVa23es/edit#gid=0" target="_blank" rel="noopener">Here&lt;/a> is an updated list of certified Kubernetes offerings and the versions they support, and &lt;a href="https://github.com/cncf/k8s-conformance" target="_blank" rel="noopener">here&lt;/a> is more info on conformance.&lt;/p>
&lt;p>If you do not agree with my conclusions, or you feel like I have missed something, please leave a comment!&lt;/p></description></item><item><title>Rapid API</title><link>https://www.kleinloog.ch/project/rapid-api/</link><pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/project/rapid-api/</guid><description>&lt;p>This goal of this project is to come up with an approach for rapid prototyping of APIs that support both REST and GraphQL.&lt;/p>
&lt;h2 id="the-what">The What&lt;/h2>
&lt;p>A containerized starting point that can be used to quickly implement a prototype of an API, customize it as needed, and easily add initial content.&lt;/p>
&lt;p>My main requirements:&lt;/p>
&lt;ul>
&lt;li>Support for RESTful APIs&lt;/li>
&lt;li>Support for GraphQL APIs&lt;/li>
&lt;li>Easily modify the API and add initial content&lt;/li>
&lt;li>Free of costs (no licence fees)&lt;/li>
&lt;/ul>
&lt;p>Additional nice to haves:&lt;/p>
&lt;ul>
&lt;li>Support for Webhooks&lt;/li>
&lt;li>Support for Authentication&lt;/li>
&lt;li>Support for Open API documentation&lt;/li>
&lt;/ul>
&lt;h2 id="the-why">The Why&lt;/h2>
&lt;p>Every now and then I find myself in a situation where I need to quickly create a prototype of an API.
This often happens when exploring a design for a new Microservice, especially when that Microservice depends on other services.&lt;/p>
&lt;p>In order to properly allocate responsibilities and design the interactions between these Microservice, I often find it useful to create some working prototypes of the Microservices I depend on.&lt;/p>
&lt;p>Being able to do so quickly, while having a rich feature set at the same time, enables me to follow the &lt;strong>show me&lt;/strong> approach to software architecture, which I find far more interesting and effective, and therefore more valuable, than the more common diagrams-based &lt;strong>tell me&lt;/strong> approach.&lt;/p>
&lt;h2 id="the-how">The How&lt;/h2>
&lt;p>The &lt;a href="https://strapi.io/" target="_blank" rel="noopener">strapi&lt;/a> project was initially created to boot&lt;strong>strap&lt;/strong> &lt;strong>API&lt;/strong>s. Even though it is now advertised as a Headless CMS, from what I have seen, it could be a very good fit for what I need.&lt;/p>
&lt;p>Based on strapi, I will create a docker image that is pre-configured and ready to use. In the process, I will tailor the image to my needs and in addition, set up an automated build that pushes new versions of that image to &lt;a href="https://hub.docker.com" target="_blank" rel="noopener">docker hub&lt;/a>.
This is something that I did not do before, so a good opportunity to learn.&lt;/p>
&lt;h2 id="the-results">The Results&lt;/h2>
&lt;p>See &lt;a href="https://www.kleinloog.ch/post/rapid-api-prototype">this post&lt;/a> for a detailed description of the process and how to use it.&lt;/p>
&lt;p>The resulting container to get you going with rapid API prototyping is available on docker hub &lt;a href="https://hub.docker.com/r/akleinloog/rapid-api" target="_blank" rel="noopener">here&lt;/a> and can be started as follows:&lt;/p>
&lt;pre>&lt;code class="language-r">docker run -p 8080:8080 akleinloog/rapid-api
&lt;/code>&lt;/pre>
&lt;p>The code is available in this &lt;a href="https://github.com/akleinloog/rapid-api" target="_blank" rel="noopener">GitHub repository&lt;/a>.&lt;/p>
&lt;p>Use it freely, learn from it, and ideally, provide some feedback!&lt;/p></description></item><item><title>Setting up this Blog - Part 2</title><link>https://www.kleinloog.ch/post/my-blog-pt2/</link><pubDate>Sat, 09 May 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/post/my-blog-pt2/</guid><description>&lt;p>This is the second part in a series of posts detailing the set up of my personal blog.
It details how to enable google analytics, commenting and a simple contact page.
See &lt;a href="https://www.kleinloog.ch/post/my-blog-pt1">part 1&lt;/a> for the basic setup.&lt;/p>
&lt;h2 id="enable-google-analytics">Enable Google Analytics&lt;/h2>
&lt;p>&lt;a href="https://marketingplatform.google.com/about/analytics/" target="_blank" rel="noopener">Google Analytics&lt;/a> can provide you with some interesting insights on your site&amp;rsquo;s visitors and the way they use your site. Enabling it on my personal blog provides a nice opportunity to learn a bit more about the possibilities it offers to site owners.&lt;/p>
&lt;p>Lucky for me, it is a straight forward exercise. After signing up for google analytics and creating an account for your website, all you need to do is open your &lt;em>params.toml&lt;/em> in _/config/&lt;em>default&lt;/em> and add the account id:&lt;/p>
&lt;pre>&lt;code class="language-toml">############################
## Marketing
############################
[marketing]
google_analytics = &amp;quot;UA-***&amp;quot;
# google_tag_manager = &amp;quot;&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>I signed up for &lt;a href="https://marketingplatform.google.com/about/tag-manager/" target="_blank" rel="noopener">Google Tag Manager&lt;/a> as well, and tried to activate it, but no luck so far. In order to get Google Analytics to work I had to comment out the &lt;em>google_tag_manager&lt;/em> entry. If I decide to take another look at this and get it to work, I&amp;rsquo;ll detail it in a follow up post.&lt;/p>
&lt;p>The next step is to configure the base URL of your site, in &lt;em>config.toml&lt;/em> in _/config/&lt;em>default&lt;/em>. If you used a custom domain:&lt;/p>
&lt;pre>&lt;code class="language-toml"># The URL of your site.
baseurl = &amp;quot;https://www.yourdomain.com/&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Otherwise, use your GitHub Pages URL:&lt;/p>
&lt;pre>&lt;code class="language-toml"># The URL of your site.
baseurl = &amp;quot;https://&amp;lt;username here&amp;gt;.github.io/&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>The last change is an improvement to the deploy script we created in the previous post.
In &lt;em>deploy.sh&lt;/em> replace the following:&lt;/p>
&lt;pre>&lt;code class="language-bash">echo &amp;quot;Running Hugo Build&amp;quot;
hugo -t academic
&lt;/code>&lt;/pre>
&lt;p>with:&lt;/p>
&lt;pre>&lt;code class="language-bash">echo &amp;quot;Running Hugo Build&amp;quot;
env HUGO_ENV=&amp;quot;production&amp;quot; hugo --gc --minify -t academic -b https://&amp;lt;username here&amp;gt;.github.io
&lt;/code>&lt;/pre>
&lt;p>Doing so will activate the Google Analytics scripts when the site is running in production. In addition, it also &lt;a href="https://gohugo.io/commands/hugo/" target="_blank" rel="noopener">instructs Hugo&lt;/a> to run some cleanup tasks after the build and to minify the output, something I didn&amp;rsquo;t pay attention to in my previous post.&lt;/p>
&lt;h2 id="enable-google-search-console">Enable Google Search Console&lt;/h2>
&lt;p>Another thing I decided to add is &lt;a href="https://search.google.com/search-console/about" target="_blank" rel="noopener">Google Search Console&lt;/a>, another free-to-use service offered by Google that helps you monitor, maintain, and troubleshoot your site&amp;rsquo;s presence in Google Search results.&lt;/p>
&lt;p>After using the &amp;lsquo;URL prefix&amp;rsquo; method, my site ownership was automatically verified based on the Google Analytics account. I added an additional verification method by going to &lt;em>Settings-&amp;gt;Ownership Verification&lt;/em>, and selecting &lt;em>HTML File&lt;/em>. Download the file, add it to your &lt;em>/static&lt;/em> folder and redeploy the site:&lt;/p>
&lt;pre>&lt;code class="language-bash">./deploy.sh
&lt;/code>&lt;/pre>
&lt;p>Of course I realize that, as is the case with most &amp;lsquo;free service&amp;rsquo; offerings, I am being part of the product here. Google will use all information they get in ways they see fit. Since what I am doing here is &amp;lsquo;out in the open&amp;rsquo; and dedicated to the public domain, I figured it would make a good opportunity to learn more about these Google services, and I appreciate that the collected information (or at least some of it) is shared with me as well.&lt;/p>
&lt;h2 id="commenting-with-disqus">Commenting with Disqus&lt;/h2>
&lt;p>Enabling others to comment on your site turns it into an interactive site and is relatively easy to do.
First go to &lt;a href="https://disqus.com">https://disqus.com&lt;/a> and sign up. I selected the basic, free package. Then open &lt;em>params.toml&lt;/em> in your _config/&lt;em>default&lt;/em> directory and fill in the comments section to enable commenting:&lt;/p>
&lt;pre>&lt;code class="language-toml">############################
## Comments
############################
[comments]
...
engine = 1
...
[comments.disqus]
shortname = &amp;quot;&amp;lt;shortname&amp;gt;&amp;quot; # Paste the shortname from your Disqus dashboard
&lt;/code>&lt;/pre>
&lt;p>When you run the site locally, the commenting section won&amp;rsquo;t be enabled, but you should see a warning like
&lt;em>&amp;ldquo;Disqus comments not available by default when the website is previewed locally.&amp;quot;&lt;/em> at the bottom of your posts.&lt;/p>
&lt;p>Deploy your website to production and see how it works!&lt;/p>
&lt;h2 id="contact-page">Contact Page&lt;/h2>
&lt;p>Adding a simple contact page can be done with Academic&amp;rsquo;s &lt;a href="https://sourcethemes.com/academic/docs/page-builder/#contact" target="_blank" rel="noopener">contact widget&lt;/a>.&lt;/p>
&lt;p>For this side, I decided to add it to the bottom of the about page, and in addition, add a top-level menu and a link from my profile.&lt;/p>
&lt;p>To add a top level menu, open _config/&lt;em>default/menus.toml&lt;/em> and add:&lt;/p>
&lt;pre>&lt;code class="language-toml">[[main]]
name = &amp;quot;Contact&amp;quot;
url = &amp;quot;about/#contact&amp;quot;
weight = 50
&lt;/code>&lt;/pre>
&lt;p>In _config/&lt;em>default/params.toml&lt;/em>, make sure that an email address is configured.&lt;/p>
&lt;p>To add a link from your profile, open _authors/admin/&lt;em>index.md&lt;/em> and add this to the social section:&lt;/p>
&lt;pre>&lt;code class="language-toml">- icon: envelope
icon_pack: fas
link: 'about/#contact'
&lt;/code>&lt;/pre>
&lt;p>To add the contact form itself, in the &lt;em>content/about/&lt;/em> folder, add contact.md with the following content:&lt;/p>
&lt;pre>&lt;code class="language-toml">+++
# Contact widget.
widget = &amp;quot;contact&amp;quot;
headless = true
active = true
weight = 50
title = &amp;quot;Contact&amp;quot;
subtitle = &amp;quot;&amp;quot;
# Automatically link email and phone?
autolink = true
# Email form provider
# 0: Disable email form
# 1: Netlify (requires that the site is hosted by Netlify)
# 2: formspree.io
email_form = 2
+++
&lt;/code>&lt;/pre>
&lt;p>This sets up your site to use &lt;a href="https://formspree.io/" target="_blank" rel="noopener">Formspree&lt;/a> to email you the request.
After deploying to production, simply fill in the form once and you will receive an email to complete your registration.
Their free plan gives you a limited amount of monthly submissions.&lt;/p>
&lt;p>The contact widget can be further customized by providing additional information in your &lt;em>params.toml&lt;/em>, see the &lt;a href="https://sourcethemes.com/academic/docs/page-builder/#contact" target="_blank" rel="noopener">docs&lt;/a> for more detail.&lt;/p></description></item><item><title>Setting up this Blog - Part 1</title><link>https://www.kleinloog.ch/post/my-blog-pt1/</link><pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/post/my-blog-pt1/</guid><description>&lt;p>Welcome to the first in a series of posts that detail how I set up of this blog. It covers the basic steps needed to get started.&lt;/p>
&lt;p>I use &lt;a href="https://gohugo.io" target="_blank" rel="noopener">Hugo&lt;/a> as a static site generator and &lt;a href="https://code.visualstudio.com" target="_blank" rel="noopener">Visual Studio Code&lt;/a> as editor. The resulting website is hosted using &lt;a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages&lt;/a>. A nice combination of open source tools with a free hosting provider that poses no restrictions in terms of traffic, size, etc.
Sounds like a perfect match to me.&lt;/p>
&lt;p>Familiarity with git and the command line are assumed. I use a Mac, some of the commands may need to be translated to your environment.&lt;/p>
&lt;h2 id="getting-started">Getting started&lt;/h2>
&lt;p>Following this &lt;a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/" target="_blank" rel="noopener">Hugo tutorial&lt;/a>, I created two repositories on GitHub.
One named &lt;em>website&lt;/em> for the &lt;a href="https://github.com/akleinloog/website" target="_blank" rel="noopener">sources&lt;/a>, and another one for the &lt;a href="https://github.com/akleinloog/akleinloog.github.io" target="_blank" rel="noopener">generated website&lt;/a>.&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
The name of the repository for the generated website has to be specific in order for it to be picked up by GitHub Pages.
In my case: &lt;strong>akleinloog.github.io&lt;/strong>
&lt;/div>
&lt;/div>
&lt;p>I decided to dedicate both repositories to the public domain and therefore used the &lt;a href="https://choosealicense.com/licenses/unlicense/" target="_blank" rel="noopener">UNLICENSE&lt;/a>.
Feel free to use anything you find there as you see fit.&lt;/p>
&lt;p>The next step is to clone the repository used for the source:&lt;/p>
&lt;pre>&lt;code class="language-bash">git clone https://github.com/&amp;lt;username here&amp;gt;/website.git
&lt;/code>&lt;/pre>
&lt;p>And open the project in Visual Studio Code:&lt;/p>
&lt;pre>&lt;code class="language-bash">cd website
code .
&lt;/code>&lt;/pre>
&lt;p>Add the following .gitignore file and optionally, save the code workspace:&lt;/p>
&lt;pre>&lt;code class="language-r"># MacOS Files
.DS_Store
# Hugo Working Folders
resources/
&lt;/code>&lt;/pre>
&lt;p>Install Hugo if not already installed:&lt;/p>
&lt;pre>&lt;code class="language-bash">brew install hugo
&lt;/code>&lt;/pre>
&lt;p>And initialize your repository for Hugo:&lt;/p>
&lt;pre>&lt;code class="language-bash">hugo new site . --force
&lt;/code>&lt;/pre>
&lt;h2 id="select-a-theme">Select a theme&lt;/h2>
&lt;p>A good overview of available themes can be found &lt;a href="https://jamstackthemes.dev" target="_blank" rel="noopener">here&lt;/a>.
Select Hugo and order the themes by Stars gives you an overview of the most used themes.&lt;/p>
&lt;p>I decided to try &lt;a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic&lt;/a>, a feature rich, open source theme developed by George Cushen and made available under the &lt;a href="https://choosealicense.com/licenses/mit/" target="_blank" rel="noopener">MIT&lt;/a> license. Thanks George!&lt;/p>
&lt;p>Add the theme as a git submodule:&lt;/p>
&lt;pre>&lt;code class="language-bash">git submodule add https://github.com/gcushen/hugo-academic.git themes/academic
&lt;/code>&lt;/pre>
&lt;p>Familiarize yourself with Academic, and &lt;a href="https://sourcethemes.com/academic/docs/customization/" target="_blank" rel="noopener">customize&lt;/a> it as you see fit.
A good way to do that, is to clone the &lt;a href="https://github.com/sourcethemes/academic-kickstart" target="_blank" rel="noopener">Academic Kickstart&lt;/a> project in a separate directory.
It provides a good demonstration of what the theme has to offer.&lt;/p>
&lt;h2 id="add-some-content">Add some content&lt;/h2>
&lt;p>First add the configuration files. You can copy the ones from the Academic Kickstart project to get started. Read through them and adjust as you see fit.&lt;/p>
&lt;p>Also copy the &lt;em>page_sharer.toml&lt;/em> file in the &lt;em>data&lt;/em> folder to your local project.&lt;/p>
&lt;p>Playing around with Academic&amp;rsquo;s many widgets using the Kickstart project should give you a fair idea on what other content you want to add.
You can also have a look at my &lt;a href="https://github.com/akleinloog/website" target="_blank" rel="noopener">sources repository&lt;/a> to see what I did for this blog.&lt;/p>
&lt;h2 id="try-it-out-locally">Try it out locally&lt;/h2>
&lt;p>Experiment with the configuration options and the structure. Run the site in development mode using:&lt;/p>
&lt;pre>&lt;code class="language-bash">hugo server
&lt;/code>&lt;/pre>
&lt;p>The site will be available at &lt;em>http://localhost:1313&lt;/em>.
Whenever you save your changes, Hugo will react and automatically refresh the website, providing a very pleasant live-editing experience.&lt;/p>
&lt;h2 id="get-ready-to-publish">Get ready to publish&lt;/h2>
&lt;p>Add the repository for the generated website as a git submodule:&lt;/p>
&lt;pre>&lt;code class="language-bash">git submodule add -b master https://github.com/&amp;lt;username here&amp;gt;/&amp;lt;username here&amp;gt;.github.io.git public
&lt;/code>&lt;/pre>
&lt;p>Doing so ensures that the HTML and JavaScript generated by Hugo will be placed in that repository.&lt;/p>
&lt;p>First, we&amp;rsquo;ll do a manual run. Generate your website:&lt;/p>
&lt;pre>&lt;code class="language-bash">hugo -t academic
&lt;/code>&lt;/pre>
&lt;p>Test the generated output using the &lt;a href="https://www.npmjs.com/package/serve" target="_blank" rel="noopener">serve package&lt;/a>:&lt;/p>
&lt;pre>&lt;code class="language-bash">cd public
npx serve
&lt;/code>&lt;/pre>
&lt;h2 id="automate-it">Automate it&lt;/h2>
&lt;p>Add a file called deploy.sh to the sources repository&amp;rsquo;s main folder. Ensure it is executable:&lt;/p>
&lt;pre>&lt;code class="language-bash">chmod +x deploy.sh
&lt;/code>&lt;/pre>
&lt;p>Add the following content to that file:&lt;/p>
&lt;pre>&lt;code class="language-bash">#!/bin/sh
set -e
echo &amp;quot;Cleaning Publish Folder&amp;quot;
rm -r ./public/*
echo &amp;quot;Running Hugo Build&amp;quot;
hugo -t academic
cd public
echo &amp;quot;Adding changes to git&amp;quot;
git add .
msg=&amp;quot;regenerating site content $(date)&amp;quot;
git commit -m &amp;quot;$msg&amp;quot;
echo &amp;quot;Pushing to master&amp;quot;
git push origin master
cd ..
echo &amp;quot;Deployment Finished&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>This script uses Hugo to generate your website and commit the changes to the generated website repository.
By pushing these changes to GitHub, the script effectively deploys your website to production. Give it a try:&lt;/p>
&lt;pre>&lt;code>./deploy.sh
&lt;/code>&lt;/pre>
&lt;p>Navigate to your GitHub Pages URL to see the result!&lt;/p>
&lt;h2 id="add-a-custom-domain-name">Add a custom domain name&lt;/h2>
&lt;p>Using a custom domain name for your GitHub pages is relatively straight forward.
First register a domain name and then configure the &lt;a href="https://kb.pressable.com/article/dns-record-types-explained/" target="_blank" rel="noopener">DNS settings&lt;/a>.&lt;/p>
&lt;p>Create the following A records for your domain to point it to GitHub&amp;rsquo;s servers:&lt;/p>
&lt;pre>&lt;code>185.199.108.153
185.199.109.153
185.199.110.153
185.199.111.153
&lt;/code>&lt;/pre>
&lt;p>Then add a CNAME record for www that points to the your GitHub site.&lt;/p>
&lt;p>Then go to the GitHub repository settings of your generated site.
In the GitHub Pages section, enter the domain you&amp;rsquo;ve registered in the custom domain field, with the &lt;strong>www.&lt;/strong> prefix, and save it.
This will trigger a check-in that adds a CNAME file with the domain that you have specified.&lt;/p>
&lt;p>Keep in mind that may take some time for DNS changes to take effect, and for the SSL certificates to be generated.
Once completed, check the &amp;lsquo;Enforce HTTPS&amp;rsquo; checkbox and the setup is completed.&lt;/p>
&lt;p>Your domain name will be forwarded to your &lt;strong>www.&lt;/strong> and so will your GitHub pages and HTTPS will be automatically enforces, with valid a certificate for your URL, free of charge!&lt;/p>
&lt;p>See the GitHub Pages docs for &lt;a href="https://help.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site" target="_blank" rel="noopener">more information&lt;/a> and &lt;a href="https://help.github.com/en/github/working-with-github-pages/troubleshooting-custom-domains-and-github-pages" target="_blank" rel="noopener">troubleshooting tips&lt;/a>.&lt;/p>
&lt;h2 id="update-the-source-repository">Update the source repository&lt;/h2>
&lt;p>The last thing to do, before making other modifications to your site, is to secure the CNAME file in your source repository so that it does not get deleted when the website is regenerated. First pull the changes:&lt;/p>
&lt;pre>&lt;code class="language-bash">cd public
git pull --all
&lt;/code>&lt;/pre>
&lt;p>This will update the local module and add the CNAME file. Now copy that file from the &lt;em>public&lt;/em> folder to the &lt;em>static&lt;/em> folder so it will be re-added when the site is regenerated. Commit and push your changes and you are good to go!&lt;/p>
&lt;h2 id="next-steps">Next Steps&lt;/h2>
&lt;p>I hope you may have learned something from this, as I did. In &lt;a href="https://www.kleinloog.ch/post/my-blog-pt2">Part 2&lt;/a> I will add support for Google Analytics, comments and a simple contact page.&lt;/p></description></item><item><title>Personal Blog</title><link>https://www.kleinloog.ch/project/personal-blog/</link><pubDate>Tue, 05 May 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/project/personal-blog/</guid><description>&lt;p>The goal of this mini-project was to set up a simple website to use as a personal blog.
You are currently looking at the result of it.&lt;/p>
&lt;h2 id="the-what">The What&lt;/h2>
&lt;p>The basic idea was to set up a simple blog that allows me to manage posts on some topics that interest me and to provide some info on some of the projects I work on.
Having played around with Wordpress in the past, I wanted to try something different this time.&lt;/p>
&lt;p>My main requirements:&lt;/p>
&lt;ul>
&lt;li>Easy to use (for me, so opinionated)&lt;/li>
&lt;li>Easy to host, on a custom domain with HTTPS&lt;/li>
&lt;li>Free of costs, no licence or hosting fees&lt;/li>
&lt;li>Learn something new in the process&lt;/li>
&lt;/ul>
&lt;h2 id="the-why">The Why&lt;/h2>
&lt;p>My main motivation is to have a place to keep track of some of the technical experiments I do and their outcomes.
A blog that allows me to write small posts, tag them, and easily search through them seemed like a good solution.&lt;/p>
&lt;p>If others may find these experiments and learn from them, that would be an additional benefit.
And if in turn they would provide feedback, even better!&lt;/p>
&lt;h2 id="the-how">The How&lt;/h2>
&lt;p>After looking around a bit I decided to try out the following:&lt;/p>
&lt;ul>
&lt;li>Use &lt;a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo&lt;/a>, a static site generator written in &lt;a href="https://golang.org/" target="_blank" rel="noopener">Go&lt;/a>&lt;/li>
&lt;li>Write the content in &lt;a href="https://www.markdownguide.org/" target="_blank" rel="noopener">markdown&lt;/a>&lt;/li>
&lt;li>Use a &lt;a href="https://github.com/akleinloog/website" target="_blank" rel="noopener">GitHub repository&lt;/a> to keep the sources&lt;/li>
&lt;li>Use another &lt;a href="https://github.com/akleinloog/akleinloog.github.io" target="_blank" rel="noopener">GitHub repository&lt;/a> to host the resulting blog&lt;/li>
&lt;li>Open Source the result so others might learn from it&lt;/li>
&lt;/ul>
&lt;h2 id="the-results">The Results&lt;/h2>
&lt;p>The current state of this project is open for all to see. Look around and take a look at the sources if you are interested.&lt;/p>
&lt;p>This is a work in progress, posts will be added and edited to my likings, and I hope to add some additional features every now and then as well.&lt;/p>
&lt;p>I hope you may find this useful somehow!&lt;/p></description></item><item><title>About</title><link>https://www.kleinloog.ch/about/</link><pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/about/</guid><description/></item><item><title>Projects</title><link>https://www.kleinloog.ch/portfolio/</link><pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate><guid>https://www.kleinloog.ch/portfolio/</guid><description/></item></channel></rss>